#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#
#   ind_vect <- append(ind_vect, NA)
#
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
amwo_hmm_final <- amwo_hmm_final %>%
filter(ID != "PA-2019-13-2019",
ID != "RI-2019-18-2019",
ID != "RI-2019-29-2019",
ID != "VT-2020-04-2020")
amwo_hmm_final <- amwo_hmm_final %>%
mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here::here("classifier_fall", "fall_all_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_fall", "fall_all_4_state_parameters.rds"))
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
load(file=here("classifier_spring", "spring_female_data.RData"))
RI_problems <- c("ME-2018-13-2019")
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
group_by(ID) %>%
mutate(ranks = row_number()) %>%
mutate(known = ifelse(ranks == "1", 1, NA)) %>%
mutate(known = ifelse(ID == "VA-2019-22-2019" & ranks < 6, 1, known)) %>% #accidentally slips into 3 too early
mutate(known = ifelse(ID == "VA-2021-91-2021" & ranks %in% c(16, 17, 18), 2, known)) %>% #crw stops the bird from slipping into mig
mutate(known = ifelse(ID == "VA-2021-92-2021" & ranks %in% c(6, 7, 8), 2, known)) %>% #crw stops the bird from slipping into mig
mutate(known = ifelse(ID == "NJ-2018-15-2019" & julian_day == 46, 2, known)) %>%
mutate(known = ifelse(ID == "VA-2019-22-2019" & julian_day == 99, 2, known)) %>%
pull(known)
stateNames <- c("pre", "migration", "stopover", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern", log_mean_dist_7 = "norm", residence_time = "norm") #,
fixPar <- list(beta=matrix(c(NA, -1000,	-1000,	-1000,	NA,	NA,	-1000,	NA,	-1000,	-1000,	-1000,	-1000), nrow = 1, byrow = TRUE),
step_500 = c(0.000000001, 0.999999999, 0.000000001, 0.000000001))
Par0_m1 <- list(step=c(0.260832696, 9.429288e+01, 0.323209095, 0.1581120, #mean in km
0.434046082, 9.829083e+01, 0.565636024 , 0.2682378, # SD in km
0.002864053, 1.549953e-09, 0.008935152, 0.0101826), #zeromass ie how many zeroes expected in the distribution
angle=c(0.001212793, -0.004443658, -0.004534878, 0.0003999368, #mean
0.882238488, 0.911903062, 0.405040026, 0.7535390314),
y = c(35.142723, 40.642156, 41.012048,  44.801910,
2.567658, 4.407258, 3.666311, 3.010217),
julian_day = c(41.63823, 86.00518, 88.73997, 141.08671, #mean
20.60346, 26.04991, 25.50664, 23.33606),#concentration
log_mean_dist_7 = c(3.601858, 9.920471, 4.539150, 3.114167, #mean
1.610840, 2.643817, 2.938573, 1.637662), #sd
residence_time = c(49.87944, 7.546966, 26.48728, 66.52459, #mean
21.66159, 16.575491, 20.09901, 22.88829), #sd
dist_start = c(0.01667985, 0.9264421, 0.9762556, 0.999999), #prob
step_500 = c(0.002299856, 0.99999, 7.443581e-09, 0.00255622), #prob
breeding_abundance = c(0.1159913, 0.4453295, 0.5308599, 0.8146863)) #prob
fit_and_predict <- function(.x){
set.seed(8)
m1 <- fitHMM(data=.x, nbStates=4, dist=dist, Par0 = Par0_m1,
estAngleMean = list(angle=TRUE),
fixPar=fixPar,
#userBounds = userBounds,
#workBounds = workBounds,
#DM = DM,
knownStates = knownStates,
#formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
stateNames = stateNames)
.x$step_state <- viterbi(m1)
#step state shows the bird's behavior between points, point state shows the birds behavior at points
.x$point_state <- map(1:nrow(.x),  function(i){
if(i == 1 | i == 1){
return(1) #for the first and second rows, return 1
} else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
return(1)
} else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
return(.x[i,"step_state"])
} else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1 & .x[i,"ID"] == .x[i-2,"ID"]){ #is the current step state mig and the previous step pre-mig, and is this not step 1 or 2? Return pre-mig
return(1)
} else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
return(3)
} else{ #in all other circumstances, return the current step state
return(.x[i,"step_state"])
}
}) %>% unlist()
return(list(model = m1, results = .x))
}
start_time <- Sys.time()
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states
end_time <- Sys.time()
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag
amwo_hmm_final <- results_initial$results
results_initial$model #probabilities of transition
print(start_time)
print(end_time)
amwo_hmm_final <- amwo_hmm_final %>%
group_by(ID) %>%
group_modify(function(iter_df, y){
iter_df <- iter_df %>%
mutate(., row_num = 1:nrow(.))
first_30km_step <- iter_df %>%
filter(step > 30.2) %>%
pull(row_num) %>%
min(na.rm = TRUE)
iter_df %>%
mutate(point_state = if_else(row_num <= first_30km_step, 1, point_state)) %>%
return()
}) %>%
ungroup() %>%
mutate(row_num = NULL)
amwo_hmm_final <- amwo_hmm_final %>%
group_by(ID) %>%
group_modify(function(iter_df, y){
final_state <- pull(tail(iter_df, 1), point_state)
if(final_state == 4){ #if the last point is in a final state, all locations after the last 30.2 km movement are also in a final state
iter_df <- iter_df %>%
mutate(., row_num = 1:nrow(.))
last_30km_step <- iter_df %>%
filter(step > 30.2) %>%
pull(row_num) %>%
max(na.rm = TRUE)
iter_df <- iter_df %>%
mutate(point_state = if_else(row_num > last_30km_step, 4, point_state))
}
return(iter_df)
}) %>%
ungroup() %>%
mutate(row_num = NULL)
# early_spring_movement %>%
#   mutate(step_state = 1, point_state = 1) ->
#   early_spring_movement
#
# amwo_hmm %>%
#   rbind(early_spring_movement) ->
#   amwo_hmm
# amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
#   #print(ind)
#   amwo_ind <- amwo_hmm_final %>%
#     filter(ID == ind)
#
#   ind_vect <- c()
#
#   for(i in 1:(nrow(amwo_ind)-1)){
#     #print(i)
#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#
#   ind_vect <- append(ind_vect, NA)
#
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
amwo_hmm_final <- amwo_hmm_final %>%
filter(ID != "NJ-2019-28-2020",
ID != "NS-2019-02-2020",
ID != "RI-2020-42-2021",
ID != "RI-2021-47-2022", #midatlantic transitory movement
ID != "RI-2021-52-2022", #midatlantic transitory movement
ID != "NY-2022-40-2022") #post-nesting dispersal movement
amwo_hmm_final <- amwo_hmm_final %>%
mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here::here("classifier_spring", "spring_female_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_spring", "spring_female_4_state_parameters.rds"))
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
load(file=here("classifier_spring", "spring_female_data.RData"))
RI_problems <- c("ME-2018-13-2019")
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
group_by(ID) %>%
mutate(ranks = row_number()) %>%
mutate(known = ifelse(ranks == "1", 1, NA)) %>%
mutate(known = ifelse(ID == "VA-2019-22-2019" & ranks < 6, 1, known)) %>% #accidentally slips into 3 too early
mutate(known = ifelse(ID == "VA-2021-91-2021" & ranks %in% c(16, 17, 18), 2, known)) %>% #crw stops the bird from slipping into mig
mutate(known = ifelse(ID == "VA-2021-92-2021" & ranks %in% c(6, 7, 8), 2, known)) %>% #crw stops the bird from slipping into mig
mutate(known = ifelse(ID == "NJ-2018-15-2019" & julian_day == 46, 2, known)) %>%
mutate(known = ifelse(ID == "VA-2019-22-2019" & julian_day == 99, 2, known)) %>%
mutate(known = ifelse(known == 1 & ID %in% RI_problems, 2, known)) %>%
pull(known)
stateNames <- c("pre", "migration", "stopover", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern", log_mean_dist_7 = "norm", residence_time = "norm") #,
fixPar <- list(beta=matrix(c(NA, -1000,	-1000,	-1000,	NA,	NA,	-1000,	NA,	-1000,	-1000,	-1000,	-1000), nrow = 1, byrow = TRUE),
step_500 = c(0.000000001, 0.999999999, 0.000000001, 0.000000001))
Par0_m1 <- list(step=c(0.260832696, 9.429288e+01, 0.323209095, 0.1581120, #mean in km
0.434046082, 9.829083e+01, 0.565636024 , 0.2682378, # SD in km
0.002864053, 1.549953e-09, 0.008935152, 0.0101826), #zeromass ie how many zeroes expected in the distribution
angle=c(0.001212793, -0.004443658, -0.004534878, 0.0003999368, #mean
0.882238488, 0.911903062, 0.405040026, 0.7535390314),
y = c(35.142723, 40.642156, 41.012048,  44.801910,
2.567658, 4.407258, 3.666311, 3.010217),
julian_day = c(41.63823, 86.00518, 88.73997, 141.08671, #mean
20.60346, 26.04991, 25.50664, 23.33606),#concentration
log_mean_dist_7 = c(3.601858, 9.920471, 4.539150, 3.114167, #mean
1.610840, 2.643817, 2.938573, 1.637662), #sd
residence_time = c(49.87944, 7.546966, 26.48728, 66.52459, #mean
21.66159, 16.575491, 20.09901, 22.88829), #sd
dist_start = c(0.01667985, 0.9264421, 0.9762556, 0.999999), #prob
step_500 = c(0.002299856, 0.99999, 7.443581e-09, 0.00255622), #prob
breeding_abundance = c(0.1159913, 0.4453295, 0.5308599, 0.8146863)) #prob
fit_and_predict <- function(.x){
set.seed(8)
m1 <- fitHMM(data=.x, nbStates=4, dist=dist, Par0 = Par0_m1,
estAngleMean = list(angle=TRUE),
fixPar=fixPar,
#userBounds = userBounds,
#workBounds = workBounds,
#DM = DM,
knownStates = knownStates,
#formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
stateNames = stateNames)
.x$step_state <- viterbi(m1)
#step state shows the bird's behavior between points, point state shows the birds behavior at points
.x$point_state <- map(1:nrow(.x),  function(i){
if(i == 1 | i == 1){
return(1) #for the first and second rows, return 1
} else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
return(1)
} else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
return(.x[i,"step_state"])
} else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1 & .x[i,"ID"] == .x[i-2,"ID"]){ #is the current step state mig and the previous step pre-mig, and is this not step 1 or 2? Return pre-mig
return(1)
} else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
return(3)
} else{ #in all other circumstances, return the current step state
return(.x[i,"step_state"])
}
}) %>% unlist()
#Fix the RI problem birds
.x <- .x %>%
group_by(ID) %>%
mutate(ranks = row_number()) %>%
mutate(point_state = ifelse(ranks == "1" & ID %in% RI_problems, 1, point_state)) %>%
ungroup() %>%
dplyr::select(-ranks)
return(list(model = m1, results = .x))
}
start_time <- Sys.time()
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states
end_time <- Sys.time()
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag
amwo_hmm_final <- results_initial$results
results_initial$model #probabilities of transition
print(start_time)
print(end_time)
amwo_hmm_final <- amwo_hmm_final %>%
group_by(ID) %>%
group_modify(function(iter_df, y){
iter_df <- iter_df %>%
mutate(., row_num = 1:nrow(.))
first_30km_step <- iter_df %>%
filter(step > 30.2) %>%
pull(row_num) %>%
min(na.rm = TRUE)
iter_df %>%
mutate(point_state = if_else(row_num <= first_30km_step, 1, point_state)) %>%
return()
}) %>%
ungroup() %>%
mutate(row_num = NULL)
amwo_hmm_final <- amwo_hmm_final %>%
group_by(ID) %>%
group_modify(function(iter_df, y){
final_state <- pull(tail(iter_df, 1), point_state)
if(final_state == 4){ #if the last point is in a final state, all locations after the last 30.2 km movement are also in a final state
iter_df <- iter_df %>%
mutate(., row_num = 1:nrow(.))
last_30km_step <- iter_df %>%
filter(step > 30.2) %>%
pull(row_num) %>%
max(na.rm = TRUE)
iter_df <- iter_df %>%
mutate(point_state = if_else(row_num > last_30km_step, 4, point_state))
}
return(iter_df)
}) %>%
ungroup() %>%
mutate(row_num = NULL)
# early_spring_movement %>%
#   mutate(step_state = 1, point_state = 1) ->
#   early_spring_movement
#
# amwo_hmm %>%
#   rbind(early_spring_movement) ->
#   amwo_hmm
# amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
#   #print(ind)
#   amwo_ind <- amwo_hmm_final %>%
#     filter(ID == ind)
#
#   ind_vect <- c()
#
#   for(i in 1:(nrow(amwo_ind)-1)){
#     #print(i)
#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#
#   ind_vect <- append(ind_vect, NA)
#
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
amwo_hmm_final <- amwo_hmm_final %>%
filter(ID != "NJ-2019-28-2020",
ID != "NS-2019-02-2020",
ID != "RI-2020-42-2021",
ID != "RI-2021-47-2022", #midatlantic transitory movement
ID != "RI-2021-52-2022", #midatlantic transitory movement
ID != "NY-2022-40-2022") #post-nesting dispersal movement
amwo_hmm_final <- amwo_hmm_final %>%
mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here::here("classifier_spring", "spring_female_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_spring", "spring_female_4_state_parameters.rds"))
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
load(file=here("classifier_spring", "spring_female_data.RData"))
RI_problems <- c("ME-2018-13-2019")
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
group_by(ID) %>%
mutate(ranks = row_number()) %>%
mutate(known = ifelse(ranks == "1", 1, NA)) %>%
mutate(known = ifelse(ID == "VA-2019-22-2019" & ranks < 6, 1, known)) %>% #accidentally slips into 3 too early
mutate(known = ifelse(ID == "VA-2021-91-2021" & ranks %in% c(16, 17, 18), 2, known)) %>% #crw stops the bird from slipping into mig
mutate(known = ifelse(ID == "VA-2021-92-2021" & ranks %in% c(6, 7, 8), 2, known)) %>% #crw stops the bird from slipping into mig
mutate(known = ifelse(ID == "NJ-2018-15-2019" & julian_day == 46, 2, known)) %>%
mutate(known = ifelse(ID == "VA-2019-22-2019" & julian_day == 99, 2, known)) %>%
mutate(known = ifelse(ID == "ME-2018-13-2019" & julian_day == 161, 2, known)) %>%
mutate(known = ifelse(known == 1 & ID %in% RI_problems, 2, known)) %>%
pull(known)
stateNames <- c("pre", "migration", "stopover", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern", log_mean_dist_7 = "norm", residence_time = "norm") #,
fixPar <- list(beta=matrix(c(NA, -1000,	-1000,	-1000,	NA,	NA,	-1000,	NA,	-1000,	-1000,	-1000,	-1000), nrow = 1, byrow = TRUE),
step_500 = c(0.000000001, 0.999999999, 0.000000001, 0.000000001))
Par0_m1 <- list(step=c(0.260832696, 9.429288e+01, 0.323209095, 0.1581120, #mean in km
0.434046082, 9.829083e+01, 0.565636024 , 0.2682378, # SD in km
0.002864053, 1.549953e-09, 0.008935152, 0.0101826), #zeromass ie how many zeroes expected in the distribution
angle=c(0.001212793, -0.004443658, -0.004534878, 0.0003999368, #mean
0.882238488, 0.911903062, 0.405040026, 0.7535390314),
y = c(35.142723, 40.642156, 41.012048,  44.801910,
2.567658, 4.407258, 3.666311, 3.010217),
julian_day = c(41.63823, 86.00518, 88.73997, 141.08671, #mean
20.60346, 26.04991, 25.50664, 23.33606),#concentration
log_mean_dist_7 = c(3.601858, 9.920471, 4.539150, 3.114167, #mean
1.610840, 2.643817, 2.938573, 1.637662), #sd
residence_time = c(49.87944, 7.546966, 26.48728, 66.52459, #mean
21.66159, 16.575491, 20.09901, 22.88829), #sd
dist_start = c(0.01667985, 0.9264421, 0.9762556, 0.999999), #prob
step_500 = c(0.002299856, 0.99999, 7.443581e-09, 0.00255622), #prob
breeding_abundance = c(0.1159913, 0.4453295, 0.5308599, 0.8146863)) #prob
fit_and_predict <- function(.x){
set.seed(8)
m1 <- fitHMM(data=.x, nbStates=4, dist=dist, Par0 = Par0_m1,
estAngleMean = list(angle=TRUE),
fixPar=fixPar,
#userBounds = userBounds,
#workBounds = workBounds,
#DM = DM,
knownStates = knownStates,
#formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
stateNames = stateNames)
.x$step_state <- viterbi(m1)
#step state shows the bird's behavior between points, point state shows the birds behavior at points
.x$point_state <- map(1:nrow(.x),  function(i){
if(i == 1 | i == 1){
return(1) #for the first and second rows, return 1
} else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
return(1)
} else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
return(.x[i,"step_state"])
} else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1 & .x[i,"ID"] == .x[i-2,"ID"]){ #is the current step state mig and the previous step pre-mig, and is this not step 1 or 2? Return pre-mig
return(1)
} else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
return(3)
} else{ #in all other circumstances, return the current step state
return(.x[i,"step_state"])
}
}) %>% unlist()
#Fix the RI problem birds
.x <- .x %>%
group_by(ID) %>%
mutate(ranks = row_number()) %>%
mutate(point_state = ifelse(ranks == "1" & ID %in% RI_problems, 1, point_state)) %>%
ungroup() %>%
dplyr::select(-ranks)
return(list(model = m1, results = .x))
}
start_time <- Sys.time()
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states
end_time <- Sys.time()
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag
amwo_hmm_final <- results_initial$results
results_initial$model #probabilities of transition
print(start_time)
print(end_time)
amwo_hmm_final <- amwo_hmm_final %>%
group_by(ID) %>%
group_modify(function(iter_df, y){
iter_df <- iter_df %>%
mutate(., row_num = 1:nrow(.))
first_30km_step <- iter_df %>%
filter(step > 30.2) %>%
pull(row_num) %>%
min(na.rm = TRUE)
iter_df %>%
mutate(point_state = if_else(row_num <= first_30km_step, 1, point_state)) %>%
return()
}) %>%
ungroup() %>%
mutate(row_num = NULL)
amwo_hmm_final <- amwo_hmm_final %>%
group_by(ID) %>%
group_modify(function(iter_df, y){
final_state <- pull(tail(iter_df, 1), point_state)
if(final_state == 4){ #if the last point is in a final state, all locations after the last 30.2 km movement are also in a final state
iter_df <- iter_df %>%
mutate(., row_num = 1:nrow(.))
last_30km_step <- iter_df %>%
filter(step > 30.2) %>%
pull(row_num) %>%
max(na.rm = TRUE)
iter_df <- iter_df %>%
mutate(point_state = if_else(row_num > last_30km_step, 4, point_state))
}
return(iter_df)
}) %>%
ungroup() %>%
mutate(row_num = NULL)
# early_spring_movement %>%
#   mutate(step_state = 1, point_state = 1) ->
#   early_spring_movement
#
# amwo_hmm %>%
#   rbind(early_spring_movement) ->
#   amwo_hmm
# amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
#   #print(ind)
#   amwo_ind <- amwo_hmm_final %>%
#     filter(ID == ind)
#
#   ind_vect <- c()
#
#   for(i in 1:(nrow(amwo_ind)-1)){
#     #print(i)
#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#
#   ind_vect <- append(ind_vect, NA)
#
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
amwo_hmm_final <- amwo_hmm_final %>%
filter(ID != "NJ-2019-28-2020",
ID != "NS-2019-02-2020",
ID != "RI-2020-42-2021",
ID != "RI-2021-47-2022", #midatlantic transitory movement
ID != "RI-2021-52-2022", #midatlantic transitory movement
ID != "NY-2022-40-2022") #post-nesting dispersal movement
amwo_hmm_final <- amwo_hmm_final %>%
mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here::here("classifier_spring", "spring_female_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_spring", "spring_female_4_state_parameters.rds"))
