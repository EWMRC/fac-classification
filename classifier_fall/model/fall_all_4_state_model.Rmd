---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---
```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Load data
```{r}
load(file=here("classifier_fall", "fall_all_data.RData"))
```

Certain Rhode Island birds have a single pre-mig location before they migrate. Define those birds so that I can auto-classify their states as mig during classification, and stick them correctly into pre-mig in the after-classification editing
```{r}
RI_problems <- c("RI-2020-33-2020", "RI-2020-34-2020", "RI-2020-35-2020", "RI-2020-42-2020", "RI-2020-43-2020", "RI-2020-44-2020", "RI-2021-48-2021", "RI-2021-49-2021", "RI-2020-30-2020", "RI-2020-32-2020", "SC-2020-13-2020", "VT-2020-14-2020")
```

Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>% 
  mutate(known = ifelse(ranks == "1", 1, NA)) %>%
  mutate(known = ifelse(known == 1 & ID %in% RI_problems, 2, known)) %>%
  group_modify(.f = function(x, y){
    max_rank <- x %>% 
      pull(ranks) %>% 
      max()
    if(pull(y, ID) %in% spring_init_dates$ID){
      x <- x %>% 
        mutate(known = ifelse(ranks == max_rank, 4, known))
    }
    return(x)
  }) %>% 
  pull(known)
```

##### trying 3-state model with fixed state transitions

Label states and create distributions for movements
Julian day isn't in here, as it only applies to transition probabilities
```{r}
stateNames <- c("pre","migration", "stopover", "post")
dist <- list(step="gamma", angle="wrpcauchy", julian_day = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern", log_mean_dist_7 = "norm", residence_time = "norm") # y = "norm",
```

fix step length parameters and state transitions for the transition probability calculation
```{r}
fixPar <- list(beta=matrix(c(NA, -1000, -1000, # pre-migration to transitions, can't go pre- to post
                     -1000, NA, NA,  #once entered migration can't go back to pre
                     -1000, NA, -1000, #Once entered stopover, can only go back to migration
                     -1000, -1000, -1000), nrow = 1, byrow = TRUE), #once entered post-migration, can't leave
               step_500 = c(0.000000001, 0.999999999, 0.000000001, 0.000000001)) 
```

These serve as the starting parameters for the HMM to optimize for the data streams included in the random walk
```{r}
Par0_m1 <- list(step=c(0.261500539, 3.838994e+02, 0.834030041, 0.261825163, #mean in km
                       0.404219742, 4.410903e+02, 1.488383758, 0.425347015, # SD in km
                       0.003181082, 3.196105e-67, 0.003409205, 0.001801455), #zeromass ie how many zeroes expected in the distribution
                angle=c(-0.000203342, -0.07766199, 0.04102217, -0.001115973, #mean
                        0.9361437423, 0.27836443, 0.25968012, 0.827444744), #concentration
                # y = c(42.862454, 39.823877, 37.643459, 33.899562,
                #       3.101288, 4.254915, 3.484837, 2.230976),
                julian_day = c(231.3170, 266.31026, 279.18957, 316.30196, 
                        25.4405, 24.72308, 24.87789, 24.78954),
                log_mean_dist_7 = c(4.062038, 7.953790, 4.951820, 3.563583, #mean
                                1.593476, 3.889766, 2.663651, 1.548703),
                residence_time = c(56.03299, 19.56778, 30.27572, 72.30254, #mean
                                   28.02860, 24.80717, 20.52254, 19.56757),
                dist_start = c(0.003826158, 0.6588471, 0.9374171, 0.9968719), #prob
                step_500 = c(0.00001, 0.99999, 0.00001, 0.00001), #prob
                breeding_abundance = c(0.003084936, 0.2362899, 0.4301947, 0.6869913)) #sd
                # lat_diff_abs = c(0.01, 1, 0.01,
                #                  0.01, 1, 0.01,
                #                  0.026, 0.036, 0.026)) 
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=4, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               knownStates = knownStates,
               #formula = ~julian_day, #state 2 to 3. page 47 of vignette shows how to create the beta matrix. Formula for transition probabilities
               stateNames = stateNames)#nlmPar=list(print.level=2)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){
      return(1) #for the first row, return 1 
      return(1)
    } else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
      return(.x[i,"step_state"])
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig
      return(1) 
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
      return(3) 
    } else{ #in all other circumstances, return the current step state
      return(.x[i,"step_state"])
    }
    
  }) %>% unlist()
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  
  #Fix the RI problem birds
  .x <- .x %>% 
    group_by(ID) %>%
    mutate(ranks = row_number()) %>%
    mutate(point_state = ifelse(ranks == "1" & ID %in% RI_problems, 1, point_state)) %>% 
    ungroup() %>% 
    dplyr::select(-ranks)
  
  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r include = FALSE}
start_time <- Sys.time()
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states 
end_time <- Sys.time()
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm_final <- results_initial$results

results_initial$model #probabilities of transition

print(start_time)
print(end_time)
```


Ruleset: If the total step distance between the start of 4 and the most recent 3 is less than 5 km, then everything from the top of the most recent 3 down is 4

```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, y){
    iter_df <- iter_df %>%
      mutate(., row_num = 1:nrow(.))

    first_30km_step <- iter_df %>%
      filter(step > 30.2) %>%
      pull(row_num) %>%
      min(na.rm = TRUE)

    iter_df %>%
      mutate(point_state = if_else(row_num <= first_30km_step, 1, point_state)) %>%
      return()

  }) %>%
  ungroup() %>%
  mutate(row_num = NULL)
```

Ruleset: If the total step distance between the end of 1 and the 1st 3 is less than 5 km, then everything until the last 3 in that sequence is 1
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, y){
    if(pull(tail(iter_df, 1), point_state) == 4){ #if the last point is in a final state, all locations after the last 30.2 km movement are also in a final state
      iter_df <- iter_df %>%
        mutate(., row_num = 1:nrow(.))

      last_30km_step <- iter_df %>%
        filter(step > 30.2) %>%
        pull(row_num) %>%
        max(na.rm = TRUE)

      iter_df <- iter_df %>%
        mutate(point_state = if_else(row_num > last_30km_step, 4, point_state))
    }
    return(iter_df)
  }) %>%
  ungroup() %>%
  mutate(row_num = NULL)

```

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
```{r}
# summer_transient_movement %>%
#   mutate(step_state = c(3,NA), point_state = 3) ->
#   summer_transient_movement
# 
# amwo_hmm %>%
#   rbind(summer_transient_movement) ->
#   amwo_hmm
```

Correct step state based on the new point states
If:
- This point state is migratory
or
- there is a change in point state between this and the next i
then the state is migratory. otherwise, it is equal to the current point state

if we're on the last row for the individual, skip this determination and return NA

```{r}
# amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
#   #print(ind)
#   amwo_ind <- amwo_hmm_final %>%
#     filter(ID == ind)
#   
#   ind_vect <- c()
#   
#   for(i in 1:(nrow(amwo_ind)-1)){
#     #print(i)
#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#   
#   ind_vect <- append(ind_vect, NA)
#   
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
```

Remove all of the false migrations
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  filter(ID != "PA-2019-13-2019",
         ID != "RI-2019-18-2019",
         ID != "RI-2019-29-2019",
         ID != "VT-2020-04-2020")
```

```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here::here("classifier_fall", "fall_all_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_fall", "fall_all_4_state_parameters.rds"))
```