---
title: "R Notebook"
output: html_notebook
---
```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

# Forward matter
Load data
```{r}
load(file=here("classifier_fall", "fall_all_data.RData"))
```

Define those birds for which I should estimate starting states (birds tagged in VA or NJ in this season)
Defining "tagged this season" as "tagged less than 2 months (~60 days) before the first location of this seasonal delineation"
```{r}
starting_state_key <- amwo_hmm %>% #How many days before the first location of the season was this bird captured?
  left_join(capture_dates) %>% 
  group_by(ID) %>% 
  nest() %>%
  mutate(days_from_capture_to_first_loc = map(.x = data, .f = function(iter_df){
    first_time <- iter_df %>% 
      head(n = 1) %>% 
      pull(time)
    
    cap_date <- iter_df %>% 
      head(n = 1) %>% 
      pull(capture_date)
    
    as.numeric(first_time - cap_date)/24 %>% #diff time is in hours, convert to days
      return()
  }))

starting_state_key <- starting_state_key %>% 
  mutate(estimate_starting_state = if_else((str_detect(ID, pattern = "VA") | str_detect(ID, pattern = "NJ")) & days_from_capture_to_first_loc < 60, true = TRUE, false = FALSE)) %>% 
  dplyr::select(ID, estimate_starting_state) %>% 
  ungroup()

amwo_hmm <- amwo_hmm %>% 
  left_join(starting_state_key)
```

Assign a starting state for each individual
This looks clunky, but it's necessary to maintain a momentuHMMData class
Can probably get rid of some exceptions after running the revised known states
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
known_state_key <- amwo_hmm %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>% 
  mutate(known = ifelse(estimate_starting_state == FALSE & ranks == 1, yes = 1, no = NA)) %>% #if this is the first row of an ID for which I don't want to estimate starting state, the initial step is 1
  mutate(r1p1s2 = if_else(known == 1 & step > 30.2 & animal_name != "RI-2021-59", true = TRUE, false = FALSE)) %>% #if known == 1 and step >30.2, mark as a "rank 1 point 1 step 2" event to be reclassified in post-processing
  mutate(r1p1s2 = replace_na(r1p1s2, replace = FALSE)) %>% #deals with NA issues 
  mutate(known = ifelse(step > 30.2, 2, known)) %>% #if step length is >30.2, then it must be mig (even if known is already 1) 
  mutate(known = ifelse(ID == "RI-2020-42-2020" & julian_day == 331, 2, known)) %>% #fix a bird which goes into 4 too early
  mutate(known = ifelse(ID == "VA-2019-48-2019" & julian_day == 300, 4, known)) %>% #fix a bird which settles after 2/25
  mutate(known = ifelse(ID == "RI-2021-59-2021" & ranks == 1, 3, known)) %>% 
  # mutate(known = ifelse(known == 1 & ID %in% RI_problems, 2, known)) %>%
  group_modify(.f = function(x, y){ #if we know that the bird has a spring migration after this, it must settle
    max_rank <- x %>% 
      pull(ranks) %>% 
      max()
    if(pull(y, ID) %in% spring_init_dates$ID){
      x <- x %>% 
        mutate(known = ifelse(ranks == max_rank, 4, known)) #set the state of the last row to settled
    }
    return(x)
  }) %>% 
  ungroup()

amwo_hmm$known <- known_state_key$known
amwo_hmm$r1p1s2 <- known_state_key$r1p1s2

knownStates <- amwo_hmm$known
```

##### trying 3-state model with fixed state transitions

Label states and create distributions for movements
Julian day isn't in here, as it only applies to transition probabilities
```{r}
stateNames <- c("pre","migration", "stopover", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern", log_mean_dist_7 = "norm", residence_time = "norm") # ,
```

fix step length parameters and state transitions for the transition probability calculation
```{r}
fixPar <- list(beta=matrix(c(NA, -1000, -1000, # pre-migration to transitions, can't go pre- to post
                             -1000, NA, NA,  #once entered migration can't go back to pre
                             -1000, NA, -1000, #Once entered stopover, can only go back to migration
                             -1000, -1000, -1000), nrow = 1, byrow = TRUE), #once entered post-migration, can't leave
               step_500 = c(0.000000001, 0.999999999, 0.000000001, 0.000000001)) 
```

These serve as the starting parameters for the HMM to optimize for the data streams included in the random walk
```{r}
Par0_m1 <- list(step=c(0.261500539, 3.838994e+02, 0.834030041, 0.261825163, #mean in km
                       0.404219742, 4.410903e+02, 1.488383758, 0.425347015, # SD in km
                       0.003181082, 3.196105e-67, 0.003409205, 0.001801455), #zeromass ie how many zeroes expected in the distribution
                angle=c(-0.000203342, -0.07766199, 0.04102217, -0.001115973, #mean
                        0.9361437423, 0.27836443, 0.25968012, 0.827444744), #concentration
                y = c(42.862454, 39.823877, 37.643459, 33.899562,
                      3.101288, 4.254915, 3.484837, 2.230976),
                julian_day = c(231.3170, 266.31026, 279.18957, 316.30196, 
                               25.4405, 24.72308, 24.87789, 24.78954),
                log_mean_dist_7 = c(4.062038, 7.953790, 4.951820, 3.563583, #mean
                                    1.593476, 3.889766, 2.663651, 1.548703),
                residence_time = c(56.03299, 19.56778, 30.27572, 72.30254, #mean
                                   28.02860, 24.80717, 20.52254, 19.56757),
                dist_start = c(0.003826158, 0.6588471, 0.9374171, 0.9968719), #prob
                step_500 = c(0.00001, 0.99999, 0.00001, 0.00001), #prob
                breeding_abundance = c(0.003084936, 0.2362899, 0.4301947, 0.6869913)) #sd
# lat_diff_abs = c(0.01, 1, 0.01,
#                  0.01, 1, 0.01,
#                  0.026, 0.036, 0.026)) 
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x, .y, .z, .a){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=4, dist = .y, Par0 = .z,
               estAngleMean = list(angle=TRUE),
               fixPar = .a,
               knownStates = knownStates,
               #formula = ~julian_day, #state 2 to 3. page 47 of vignette shows how to create the beta matrix. Formula for transition probabilities
               stateNames = stateNames)#nlmPar=list(print.level=2)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){
      return(.x[i,"step_state"]) #for the first row, return step state 
    } else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
      return(.x[i,"step_state"])
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig
      return(1) 
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
      return(3) 
    } else{ #in all other circumstances, return the current step state
      return(.x[i,"step_state"])
    }
    
  }) %>% unlist()
  
  return(m1)
}
```

# Dredging models
Making a set of models to test
```{r}
model_sets <- map(1:7, function(x){
  combn(x = c("y", "julian_day", "log_mean_dist_7", "residence_time", "dist_start", "step_500", "breeding_abundance"), m = x, simplify = FALSE)
}) %>% 
  unlist(recursive = FALSE)

model_sets[[128]] <- character() #model with only step length and angle
```


```{r}
plan(multisession)

model_aic <- future_map(.x = model_sets, .f = function(x){
  dist_iter <- dist[names(dist) %in% c("step", "angle") | names(dist) %in% x]
  Par0_iter <- Par0_m1[names(Par0_m1) %in% c("step", "angle") | names(Par0_m1) %in% x]
  fixPar_iter <- fixPar[names(fixPar) %in% c("beta") | names(fixPar) %in% x]
  
  fit_and_predict(.x = amwo_hmm, .y = dist_iter, .z = Par0_iter, .a = fixPar_iter) %>% 
    AIC() %>% 
    return()
}, .options = furrr_options(seed = 8))

plan(sequential)

```

