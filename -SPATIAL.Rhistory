library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
ending_consideration_date <- mdy("2/25/2022")
days_subtract <- days(ending_consideration_date - mdy("12/31/2021"))
login <- movebankLogin(username = "LA_Berigan", password="33szcNUtv4iyPGU")
amwo_2017 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20170801000000000", timestamp_end = "20180225000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame() #20190115000000000
amwo_2018 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20180801000000000", timestamp_end = "20190225000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame() #20190115000000000
amwo_2019 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20190801000000000", timestamp_end = "20200225000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
amwo_2020 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20200801000000000", timestamp_end = "20210225000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
amwo_2021 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20210801000000000", timestamp_end = "20220225000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
amwo_spring <- as.data.frame(rbind(amwo_2017, amwo_2018, amwo_2019, amwo_2020, amwo_2021))
amwo_spring <- amwo_spring %>%
transmute(ID = local_identifier,
#time = as.POSIXct(round(force_tzs(timestamp, tzone = "GMT", tzone_out = "EST"), "hour")), #time rounded in EST
time = timestamp,
lon = location_long,
lat = location_lat,
tagtype = comments,
sex = sex,
age = taxon_detail,
altitude = height_above_msl)
amwo_spring <- amwo_spring %>%
mutate(t = strftime(time, format="%H:%M"),
date = strftime(time, format="%Y-%m-%d")) #%>%
#distinct(date, ID, .keep_all = TRUE) # remove multiple locations on same day, mainly retaining only 1 of 3 locations 1st day after marking
amwo_spring <- amwo_spring %>%
mutate(age = recode_factor(age,
"Second Year" = "juv",
"Hatch Year" = "juv",
"After Hatch Year" = "ad",
"After Second Year" = "ad",
"Third Year" = "ad",
"After Third Year" = "ad"))
amwo_spring <- amwo_spring %>%
separate(tagtype, c("tagtype", "second", "schedule"), sep = " ") %>%
dplyr::select(-second) %>%
mutate(ID2 = ID) %>%
separate(ID2, c("m.state", "m.year", "third"), sep = "-") %>%
dplyr::select(-third)
amwo_spring_males <- amwo_spring
# amwo_spring_males <- amwo_spring %>%
#   filter(sex == "m")
amwo_spring_males <- amwo_spring_males %>%
mutate(year = year(time-days_subtract)) %>% #boot the january locations into the previous year
mutate(animal_name = ID,
ID = paste(ID, year, sep="-"))
amwo_spring_males <- amwo_spring_males %>%
mutate(julian_day = yday(ymd(date)- days_subtract)) #subtracting to make sure that January julian days don't wrap around
# Comment this out if running repeatedly; otherwise it will just slow down the code
# googledrive::as_id("https://drive.google.com/file/d/19JA5OztH3hS4MPfVnH5zswDxSSLcWxL3/view?usp=sharing") %>%
#         googledrive::drive_download(path = here("capture_sheet.xlsx"), overwrite = TRUE)
capture_dates <- readxl::read_excel(here("capture_sheet.xlsx"), col_types = c("text", "text", "date", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text")) %>%
mutate(`Argos_ID` = as.character(`Argos_ID`)) %>%
transmute(animal_name = `Movebank_ID`,
capture_date = Date)
individuals_tagged_too_late <- amwo_spring_males %>%
left_join(capture_dates) %>%
filter((year == year(capture_date) & mdy(paste0("10/15/", year)) < capture_date)) %>% #remove locations when the bird was caught after Oct 15 in the year of concern
dplyr::select(ID, animal_name, year) %>%
distinct()
individuals_died_too_early <- amwo_spring_males %>%
mutate(time = time - days_subtract) %>%
group_by(ID) %>%
summarise(max_time = max(time)) %>%
mutate(max_date = mdy(paste0(month(max_time), "/", day(max_time), "/2020"))) %>%
filter(max_date < (mdy("12/15/2020") - days_subtract)) %>%
pull(ID)
## Reading in the initiation dates
male_spring_init_dates <- readRDS(here::here("classifier_spring", "spring_male_5_state_model.rds")) %>%
filter(step_state == 2) %>%
group_by(ID) %>%
group_modify(.f = function(x, ...){head(x, n = 1)}) %>%
ungroup() %>%
mutate(ID = paste0(animal_name, "-", (year(time) - 1))) %>% #Create IDs that will match the IDs of the previous fall, if the transmitter had been deployed then. If not, this will create invalid ids that will "come out in the wash"
transmute(ID = ID, init_time = time)
female_spring_init_dates <- readRDS(here::here("classifier_spring", "spring_female_4_state_model.rds")) %>%
filter(step_state == 2) %>%
group_by(ID) %>%
group_modify(.f = function(x, ...){head(x, n = 1)}) %>%
ungroup() %>%
mutate(ID = paste0(animal_name, "-", (year(time) - 1))) %>% #Create IDs that will match the IDs of the previous fall, if the transmitter had been deployed then. If not, this will create invalid ids that will "come out in the wash"
transmute(ID = ID, init_time = time)
spring_init_dates <- bind_rows(male_spring_init_dates, female_spring_init_dates)
## Filtering to only those locations <= the spring initiation time, should the spring initiation time exist
amwo_spring_males <- amwo_spring_males %>%
left_join(spring_init_dates) %>%
filter(is.na(init_time) | time <= init_time) %>%
dplyr::select(-init_time)
individuals_removed_for_too_few_locations <- amwo_spring_males %>%
group_by(ID) %>%
tally() %>%
filter(n < 3) %>%
pull(ID)
birds_to_keep <- amwo_spring_males %>%
group_by(ID) %>%
tally() %>%
filter(n > 2) %>%
pull(ID)
amwo_spring_males <- amwo_spring_males %>%
filter(ID %in% birds_to_keep)
# Group tracks by id (for crawl model because it likes tidyverse structure)
nested_birds <- group_by(amwo_spring_males, ID) %>%
nest()
# Movement model (no covariates = ~1)
# The constraints are based on the godwit example
# Fit model to each bird. Constrain velocity autoregression parameter to c(-7,2)
# full effective range of the beta parameter (according to D Johnson)
nested_birds <- mutate(nested_birds,
fit = purrr::map(data, ~{crawl::crwMLE(mov.model=~1,
data=.x,
coord=c("lon", "lat"), # movement model = ~1 bc no covariates
Time.name="time",
#time.scale='hours', # sometimes need to turn this on, sometimes don't
method="L-BFGS-B", # there are different optimization methods, default didn't work but this did
constr=list(lower=c(-Inf,-7), upper=c(Inf,2)),
attempts=50,
time.scale = "hours")}
)
)
nested_birds <- mutate(nested_birds,
pred = purrr::map(fit, ~{
crawl::crwPredict(.x, predTime="24 hours", return.type='flat') %>% # use 24 hours, NOT 1 day (because it rounds to the unit)
crawl::crw_as_tibble()
}
)
)
unnested_birds <- dplyr::select(nested_birds, ID, pred) %>% unnest(cols=pred)
unnested_birds <- unnested_birds %>%
mutate(locType = if_else(!is.na(lon), "o", "p"))
# amwo_hmm <- amwo_spring_males %>%
#   rename(x = lon, y = lat)
amwo_hmm <- unnested_birds %>%
rename(x = mu.x, y = mu.y) %>%
ungroup()
#remove duplicates by date to deal with predicted locations on the same day as the observed location
amwo_hmm <- amwo_hmm %>%
mutate(date = strftime(time, format="%Y-%m-%d"),
locType = factor(locType, levels = c("o", "p"), ordered = TRUE)) %>%
arrange(ID, date, locType) %>% #keep observed locations above predicted locations
distinct(date, ID, .keep_all = TRUE) %>%
mutate(julian_day = yday(ymd(date)-(days_subtract))) #Redo the julian day calculation
#Remove individuals with fewer than 3 locations, recording which ones were removed. Take 2
individuals_removed_for_too_few_locations_2 <- amwo_hmm %>%
group_by(ID) %>%
tally() %>%
filter(n < 3) %>%
pull(ID)
birds_to_keep_2 <- amwo_hmm %>%
group_by(ID) %>%
tally() %>%
filter(n > 2) %>%
pull(ID)
amwo_hmm <- amwo_hmm %>%
filter(ID %in% birds_to_keep_2)
amwo_hmm$lat_diff <- map(1:nrow(amwo_hmm),  function(i){
if(i == 1){return(NA)} else{#for the first row, return 1
if(amwo_hmm[i,"ID"] != amwo_hmm[i-1,"ID"]){ #is this the first point for this ID? Return NA
return(NA)
} else{
return(amwo_hmm[i,"y"] - amwo_hmm[i-1,"y"])
}
}
}) %>% unlist()
amwo_hmm <- amwo_hmm %>%
mutate(lat_diff_abs = abs(lat_diff)) %>%
dplyr::select(ID, animal_name, year, locType, x, y, time, date, julian_day) %>%
as.data.frame()
plan(multisession)
nested_birds_2 <- amwo_hmm %>%
group_by(ID) %>%
nest()
nested_birds_2$data <- nested_birds_2 %>%
pull(data) %>%
future_map(.f = function(x){
x <- x %>%
mutate(., rownum = 1:nrow(.))
#Transform to 5070 so I can interpolate points
x_coords <- x %>%
st_as_sf(coords = c("x", "y"), crs = 4326) %>%
st_transform(5070) %>%
st_coordinates() %>%
as.data.frame()
x$x <- x_coords$X
x$y <- x_coords$Y
observed_locs <- x %>%
filter(locType == "o")
for(i in 1:(nrow(observed_locs)-1)){
#print(i)
point_1 <- observed_locs[i,] %>%
st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
point_2 <- observed_locs[i + 1,] %>%
st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
point_dist <- st_distance(point_1, point_2,) %>%
as.numeric(.)
total_dist <- x[c(point_1$rownum, point_1$rownum:point_2$rownum),] %>%
as.data.frame() %>%
prepData(type = "UTM") %>%
pull(step) %>%
sum(na.rm = TRUE)
if(total_dist > (10*point_dist)){ #if the total step distance is more than 10 times the distance between observed points, replace with equally spaced between the points
x_step <- (point_2$x - point_1$x)/(point_2$rownum - point_1$rownum)
y_step <- (point_2$y - point_1$y)/(point_2$rownum - point_1$rownum)
for(j in (point_1$rownum+1):(point_2$rownum-1)){
#paste("Row number:", j) %>%  print()
loop_index <- j - point_1$rownum
#paste("Initial x:", x$x[j]) %>%  print()
x$x[j] <- x$x[point_1$rownum] + (x_step*loop_index)
#paste("Final x:", x$x[j]) %>%  print()
#paste("Initial y:", x$y[j]) %>%  print()
x$y[j] <- x$y[point_1$rownum] + (y_step*loop_index)
#paste("Final y:", x$y[j]) %>%  print()
}
}
}
#Cleanup
x$rownum <- NULL
#transform back to 4326
x_coords <- x %>%
st_as_sf(coords = c("x", "y"), crs = 5070) %>%
st_transform(4326) %>%
st_coordinates() %>%
as.data.frame()
x$x <- x_coords$X
x$y <- x_coords$Y
return(x)
})
amwo_hmm <- nested_birds_2 %>%
unnest(cols = c(data))
plan(sequential)
plan(multisession)
nested_birds_2.5 <- amwo_hmm %>%
group_by(ID) %>%
nest()
nested_birds_2.5$data <- nested_birds_2 %>%
pull(data) %>%
future_map(.f = function(x){
x <- x %>%
mutate(., rownum = 1:nrow(.))
#Transform to 5070 so I can interpolate points
# x_coords <- x %>%
#   st_as_sf(coords = c("x", "y"), crs = 4326) %>%
#   st_transform(5070) %>%
#   st_coordinates() %>%
#   as.data.frame()
#
# x$x <- x_coords$X
# x$y <- x_coords$Y
observed_locs <- x %>%
filter(locType == "o")
rows_to_delete <- numeric()
for(i in 1:(nrow(observed_locs)-1)){
#print(i)
point_1 <- observed_locs[i,] %>%
st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
st_transform(5070)
point_2 <- observed_locs[i + 1,] %>%
st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
st_transform(5070)
point_dist <- st_distance(point_1, point_2,) %>%
as.numeric(.)
# total_dist <- x[c(point_1$rownum, point_1$rownum:point_2$rownum),] %>%
#   as.data.frame() %>%
#   prepData(type = "UTM") %>%
#   pull(step) %>%
#   sum(na.rm = TRUE)
if(point_dist > 30200){
rows_to_delete <- rows_to_delete %>%
append(values = (point_1$rownum + 1):(point_2$rownum - 1))
}
}
x <- x %>%
filter(!(rownum %in% rows_to_delete))
#Cleanup
x$rownum <- NULL
#transform back to 4326
# x_coords <- x %>%
#   st_as_sf(coords = c("x", "y"), crs = 5070) %>%
#   st_transform(4326) %>%
#   st_coordinates() %>%
#   as.data.frame()
#
# x$x <- x_coords$X
# x$y <- x_coords$Y
return(x)
})
amwo_hmm <- nested_birds_2.5 %>%
unnest(cols = c(data))
plan(sequential)
plan(multisession)
amwo_hmm$mean_dist_7 <- amwo_hmm %>%
dplyr::select(ID, x, y) %>%
future_pmap(function(ID_iter, x_iter, y_iter){
iter_sf <- data.frame(x = x_iter, y = y_iter) %>%
st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
other_locs <- amwo_hmm %>%
st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
filter(ID == ID_iter)
st_distance(x = iter_sf, y = other_locs) %>%
as.numeric() %>%
sort() %>%
.[2:8] %>%
mean(na.rm = TRUE) %>%
return()
}) %>%
unlist()
plan(sequential)
plan(multisession)
amwo_hmm$residence_time <- amwo_hmm %>%
dplyr::select(ID, x, y) %>%
future_pmap(function(ID_iter, x_iter, y_iter){
iter_sf <- data.frame(x = x_iter, y = y_iter) %>%
st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
st_transform(5070) %>%
st_buffer(10000) %>% #10 km radius
transmute(intersection = 1)
other_locs <- amwo_hmm %>%
st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
filter(ID == ID_iter) %>%
st_transform(5070) %>%
transmute(date = ymd(date))
intersected_locs <- other_locs %>%
st_join(iter_sf) %>%
filter(intersection == 1)
as.numeric(max(intersected_locs$date, na.rm = TRUE) - min(intersected_locs$date), na.rm = TRUE) %>%
return()
}, .progress = TRUE) %>%
unlist()
plan(sequential)
plan(multisession)
nested_birds_3 <- amwo_hmm %>%
group_by(ID) %>%
nest()
nested_birds_3$data <- nested_birds_3 %>%
pull(data) %>%
future_map(.f = function(int){
int <- int %>%
st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
dist_vect <- st_distance(x = int[1,], y = int, by_element = FALSE) %>% #results in meters
as.numeric() #NOTE: NEEDS sf 1.0-9 to work correctly
# dist_vect <- log(dist_vect + 1.1)
dist_vect <- if_else(dist_vect < 16100, 0, 1)
int <- int %>%
st_drop_geometry() %>%
mutate(dist_start = dist_vect)
return(int)
}, .progress = TRUE)
amwo_hmm <- nested_birds_3 %>%
unnest(cols = c(data))
plan(sequential)
ebirdst_breeding <- terra::rast(here("ebirdst_abundance", "amewoo_abundance_seasonal_nonbreeding_max_2021.tif"))
amwo_hmm$breeding_abundance <- amwo_hmm %>%
st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
st_transform(st_crs(ebirdst_breeding)) %>%
terra::vect() %>%
terra::extract(x = ebirdst_breeding, y = .) %>%
mutate(nonbreeding = if_else(is.na(nonbreeding), 0, nonbreeding)) %>%
pull(nonbreeding)
amwo_hmm <- amwo_hmm %>% #simplify from abundance to breeding range
mutate(breeding_abundance = if_else(breeding_abundance > 0, 1, 0))
amwo_hmm <- amwo_hmm %>%
mutate(log_mean_dist_7 = log(mean_dist_7 + 0.1)) %>% #Adding a small # to deal with 0 distances
as.data.frame() %>%
prepData(type = "LL") %>% #, covNames = c("julian_day", "log_mean_dist_7")
mutate(step = round(step, digits = 4)) %>%   #round down to a tenth of a meter, which is higher than our GPS precision
mutate(step_500 = if_else(step < 30.2, 0, 1)) %>% #larger than 5km
mutate(step_500 = if_else(!is.na(step_500), step_500, 0))
# summer_transient_movement <- amwo_hmm %>%
#   mutate(id_time = paste(ID, as.character(time))) %>%
#   filter(id_time == "VA-2020-52-2020 2020-06-18 21:00:00" | id_time == "VA-2020-52-2020 2020-06-28 14:00:00") %>%
#   mutate(id_time = NULL)
#
# amwo_hmm <- amwo_hmm %>%
#   mutate(id_time = paste(ID, as.character(time))) %>%
#   filter(id_time != "VA-2020-52-2020 2020-06-18 21:00:00") %>%
#   filter(id_time != "VA-2020-52-2020 2020-06-28 14:00:00") %>%
#   mutate(id_time = NULL)
# remove a late summer movement which throws off the hmm for SC-2020-13. Also removing all of RI-2020-31-2020, as it runs up and down the midatlantic coast and doesn't have consistency in southerly direction like we'd expect for a migration
amwo_hmm <- amwo_hmm %>%
filter(!(ID == "SC-2020-13-2020" & time > ymd_hms("2020-08-27 00:00:00"))) %>%
filter(!(ID == "RI-2020-31-2020")) %>%
filter(!(ID == "ME-2018-08-2018" & time > ymd_hms("2018-12-24 00:00:00") & time < ymd_hms("2018-12-26 00:00:00"))) %>%
filter(!(ID == "NY-2018-04-2018" & time > ymd_hms("2018-11-22 00:00:00") & time < ymd_hms("2018-11-24 00:00:00"))) %>%
filter(!(ID == "PA-2021-38-2021" & time > ymd_hms("2022-01-29 12:00:00"))) #Note: this is going to either have to be manually categorized or categorized as "not designated" in the final model
amwo_hmm$min.step <- ifelse(amwo_hmm$step > 30.2, 1, 0)
individuals_removed_for_no_migratory_steps <- unique(amwo_hmm$ID [amwo_hmm$min.step == 1])
amwo_hmm <- amwo_hmm[(amwo_hmm$ID %in% amwo_hmm$ID [amwo_hmm$min.step == 1]) , ]
amwo_hmm$min.step <- NULL
save.image(file = here("classifier_fall", "fall_all_data.RData"))
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
load(file=here("classifier_spring", "spring_male_data.RData"))
id_list <- unique(amwo_hmm$ID)
id_list <- id_list[!(id_list %in% individuals_died_too_early)]
results <- readRDS(here("classifier_spring", "spring_male_5_state_model.rds"))
stateNames <- c("pre", "migration", "stopover", "settling", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", log_mean_dist_7 = "norm", residence_time = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern") #, lat_diff_abs = "gamma" , pts_10mi_log = "norm"
fixPar <- list(beta=matrix(c(NA,	-10000,	-10000,	-10000,
-10000,	NA,	NA,	NA,
-10000,	NA,	-10000, -10000,
-10000, -10000, -10000, NA,
-10000,	-10000,	-10000,	NA), nrow = 1, byrow = TRUE),
step_500 = c(NA, 0.999999999, NA, NA, NA))
Par0_m1 <- list(step=c(0.293641627, 79.029506936, 0.157361645, 0.250739740, 0.086056474, #mean in km
0.455493251, 95.302307236, 0.211421668, 0.384581337, 0.128558113, # SD in km
0.005159307, 0.006024863, 0.006664064, 0.005636388, 0.006973284), #zeromass ie how many zeroes expected in the distribution
angle=c(0.001353412, 0.0006979447, 0.01168102, 0.0005445842, 0, #mean
0.917280917, 0.9754146876, 0.59501513, 0.7614896594, 0.99999), #concentration
y = c(34.83030, 40.173268, 40.426752,  44.689995, 43.678101,
3.11158, 4.497807, 3.668652, 2.267504, 4.109156),
julian_day = c(40.14297, 79.36682, 80.54528, 135.69949, 136.7710, #mean
19.89502, 27.50774, 23.92289, 25.77254, 30.0146),
log_mean_dist_7 = c(4.126427, 9.965601, 4.959182, 3.797415, 3.581605, #mean
1.679125, 2.403601, 2.736004, 1.536724, 1.806670), #sd
residence_time = c(39.91826, 6.848351, 53.64592, 71.41284, 70.66562, #mean
20.41741, 13.174650, 35.49282, 21.65228, 25.53273), #sd
dist_start = c(0.00530222, 0.9276614, 0.9750638, 0.9955032, 0.9882519), #prob
step_500 = c(0.1336989, 0.99999, 0.06175472, 0.1351401, 0.04079765), #prob
breeding_abundance = c(0.1183127, 0.3973247, 0.442492, 0.7108834, 0.5959887)) #prob
fit_and_predict <- function(.x, ks){
set.seed(8)
m1 <- fitHMM(data=.x, nbStates=5, dist=dist, Par0 = Par0_m1,
estAngleMean = list(angle=TRUE),
fixPar=fixPar,
#userBounds = userBounds,
#workBounds = workBounds,
#DM = DM,
knownStates = ks,
#formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
stateNames = stateNames)
.x$step_state <- viterbi(m1)
#step state shows the bird's behavior between points, point state shows the birds behavior at points
.x$point_state <- map(1:nrow(.x),  function(i){
if(i == 1){
return(1) #for the first row, return 1
} else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
return(1)
} else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
return(.x[i,"step_state"])
} else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig
return(1)
} else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
return(3)
} else{ #in all other circumstances, return the current step state
return(.x[i,"step_state"])
}
}) %>% unlist()
return(list(model = m1, results = .x))
}
iterate_ids_male <- function(id_iter, jul_day_cutoff, rn){
amwo_hmm_clipped <- amwo_hmm %>% #remove locations for the ID in question after the cutoff date
filter(!(ID == id_iter & julian_day > jul_day_cutoff))
knownStates <- amwo_hmm_clipped %>%
group_by(ID) %>%
mutate(ranks = row_number()) %>%
mutate(known = ifelse(ranks == "1", 1, NA)) %>%
pull(known)
results_modified <- fit_and_predict(amwo_hmm_clipped, ks = knownStates)
#retrieve the modified ending state
end_state_modified <- results_modified$results %>%
filter(ID == id_iter & julian_day == jul_day_cutoff) %>%
pull(point_state)
#retrieve the real ending state
end_state_true <- results %>%
filter(ID == id_iter & julian_day == jul_day_cutoff) %>%
pull(point_state)
#report the cutoff date, ID, modified ending state, and real ending state in a tibble, which will be the output of the loop
tibble(cutoff_date = jul_day_cutoff,
ID = id_iter,
end_modified = end_state_modified,
end_true = end_state_true) %>%
return()
}
cutoffs <- c("3/15/2020", "4/1/2020", "4/15/2020", "5/1/2020", "5/15/2020") %>%
mdy() %>%
yday()
#now iterating through individuals
set.seed(8)
id_subsample <- id_list %>% sample(size = 50)
parameters_to_run <- expand.grid(id_subsample, cutoffs) %>%
mutate(rn = row_number())
colnames(parameters_to_run) <- c("id_iter", "jul_day_cutoff", "rn")
prior_results <- read.csv("accuracy_results_male.csv") %>% #ensure that I'm not duplicating past labor
transmute(combined = paste0(cutoff_date, "_",ID))
parameters_to_run <- parameters_to_run %>%
mutate(combined = paste0(jul_day_cutoff, "_",id_iter)) %>%
filter(!(combined %in% prior_results$combined)) %>%
mutate(combined = NULL)
plan(multisession)
tbl_list <- future_pmap(.l = parameters_to_run,
.f = iterate_ids_male,
.options = furrr_options(seed = 8))
plan(sequential)
accuracy_results_male <- tbl_list %>%
do.call(rbind, .)
# Append results to previous runs
write.table(accuracy_results_male, "accuracy_results_male.csv",
append = TRUE,
sep = ",",
col.names = FALSE,
row.names = FALSE,
quote = FALSE)
