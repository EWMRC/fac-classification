---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

This is a streamlined version of what Erik originally wrote in momentuHMM_amwo_Spring_Male2. Uses HMMs to determine if birds settle after migration, and then uses a ruleset to define when each state starts and stops

Last bit: remove all of the false migrations

```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
```

Extract all locations from 2019, 2020, and 2021 from Jan 5th through June 30th
```{r include=FALSE}
login <- movebankLogin(username = "acfish", password="EPvzvNSUJ8")
amwo_2018 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20180105000000000", timestamp_end = "20180630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2019 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20190105000000000", timestamp_end = "20190630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2020 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20200105000000000", timestamp_end = "20200630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2021 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20210105000000000", timestamp_end = "20210630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
```

Formatting and cleaning, including creating time columns and simplifying to one location per day
```{r}
amwo_spring <- as.data.frame(rbind(amwo_2018, amwo_2019, amwo_2020, amwo_2021))

amwo_spring <- amwo_spring %>%
  transmute(ID = local_identifier,
            #time = as.POSIXct(round(force_tzs(timestamp, tzone = "GMT", tzone_out = "EST"), "hour")), #time rounded in EST
            time = timestamp,
            lon = location_long,
            lat = location_lat,
            tagtype = comments,
            sex = sex,
            age = taxon_detail,
            altitude = height_above_msl)

amwo_spring <- amwo_spring %>%
  mutate(t = strftime(time, format="%H:%M"),
         date = strftime(time, format="%Y-%m-%d")) #%>%
  #distinct(date, ID, .keep_all = TRUE) # remove multiple locations on same day, mainly retaining only 1 of 3 locations 1st day after marking
```

Converting all age classes to juvenile and adult
```{r}
amwo_spring <- amwo_spring %>%
  mutate(age = recode_factor(age,
                             "Second Year" = "juv",
                             "Hatch Year" = "juv",
                             "After Hatch Year" = "ad",
                             "After Second Year" = "ad",
                             "Third Year" = "ad",
                             "After Third Year" = "ad"))
```

Extracting tag type, schedule, state marked, and year
```{r}
amwo_spring <- amwo_spring %>%
  separate(tagtype, c("tagtype", "second", "schedule"), sep = " ") %>% 
  dplyr::select(-second) %>%
  mutate(ID2 = ID) %>%
  separate(ID2, c("m.state", "m.year", "third"), sep = "-") %>% 
  dplyr::select(-third)
```

Filtering to just females and individuals with unknown sex
```{r}
amwo_spring_males <- amwo_spring %>%
  filter(sex == "f" | sex == "")
```

Account for potential duplicate years by adding a year to the end of the id
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(year = strftime(time, format="%Y")) %>%
  mutate(animal_name = ID,
         ID = paste(ID, year, sep="-"))
```

Add a julian day column (new data stream)
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(julian_day = yday(ymd(date)))
```

Remove individuals with fewer than 3 locations, recording which ones were removed
```{r}
individuals_removed_for_too_few_locations <- amwo_spring_males %>%
  group_by(ID) %>%
  tally() %>%
  filter(n < 3) %>%
  pull(ID)

rm.ID <- amwo_spring_males %>%
  group_by(ID) %>%
  tally() %>%
  filter(n > 2) %>%
  pull(ID)

amwo_spring_males <- amwo_spring_males %>%
  filter(ID %in% rm.ID)
```

Flag individuals tagged after February 15th on the year of observation so that I can mark their initial stationary state as uncertain
```{r include = FALSE}
capture_dates <- readxl::read_excel(there::here_file("Data", "Google_drive_downloads","capture_sheet.xlsx"), col_types = c("text", "text", "date", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text")) %>%
        mutate(`Argos ID` = as.character(`Argos ID`)) %>%
  transmute(animal_name = `Movebank ID`,
            capture_date = Date)

individuals_tagged_too_late <- amwo_spring_males %>%
  left_join(capture_dates) %>%
  filter((year == year(capture_date) & mdy(paste0("2/15/", year)) < capture_date)) %>% #remove locations when the bird was caught after Oct 15 in the year of concern
  dplyr::select(ID, animal_name, year) %>%
  distinct()
```

Flag individuals which died before May 15th on the year of observation so that I can mark their final stationary state as uncertain. 

### This will bias any survival analyses done with these designations ###
```{r}
individuals_died_too_early <- amwo_spring_males %>%
  group_by(ID) %>%
  summarise(max_time = max(time)) %>%
  mutate(max_date = mdy(paste0(month(max_time), "/", day(max_time), "/2020"))) %>%
  filter(max_date < mdy("5/15/2020")) %>%
  pull(ID)
```


# create momentuHMMData object; would specify covariates if included in the dataset
##  basically the step length and turn angles are now included
## Also create a data stream for difference in latitude (may be necessary for a ruleset: if not, remove)
```{r}
amwo_hmm <- amwo_spring_males %>%
  rename(x = lon, y = lat) 

amwo_hmm$lat_diff <- map(1:nrow(amwo_hmm),  function(i){
  if(i == 1){return(NA)} else{#for the first row, return 1
    if(amwo_hmm[i,"ID"] != amwo_hmm[i-1,"ID"]){ #is this the first point for this ID? Return NA
      return(NA)
    } else{
      return(amwo_hmm[i,"y"] - amwo_hmm[i-1,"y"])
    }
  }
}) %>% unlist()

amwo_hmm %>%
  mutate(lat_diff_abs = abs(lat_diff)) ->
  amwo_hmm

amwo_hmm %>%
  prepData(type = "LL", covNames = c("julian_day")) %>%
  mutate(step = round(step, digits = 2)) ->
  amwo_hmm
```

#remove early spring movements which throw off the hmm for NJ-2018-08-2019, NJ-2018-13-2019, and NJ-2018-15-2019. Add it back again at the end as a manually-delineated residential movement at the end
```{r}
# early_spring_movement <- amwo_hmm %>%
#   mutate(id_time = paste(ID, as.character(time))) %>%
#   filter(id_time == "VA-2020-52-2020 2020-06-18 21:00:00" | id_time == "VA-2020-52-2020 2020-06-28 14:00:00") %>%
#   mutate(id_time = NULL)

early_spring_movement <- amwo_hmm %>%
  filter((ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32")) |
         (ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-12 14:00:32")) |
         (ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-02 03:01:20")))

amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32"))) %>%
  filter(!(ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-12 14:00:32"))) %>%
  filter(!(ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-02 03:01:20")))

#additionally trimming RI-2020-31; I won't add it back in (not necessary for this workflow). Algorithm catches the tail end of fall migration and pushes it into spring mig too early.
amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "RI-2020-31-2021" & time <= ymd_hms("2021-03-02 18:59:12")))

```

remove birds with no individual step lengths >30.2km (20 miles). In practice this pulls birds that never initiate a substantial migratory movement but doesn't penalize birds that DO migrate, as they always make at least one substantial movement.
Also recording which individuals are removed
```{r}
amwo_hmm$min.step <- ifelse(amwo_hmm$step>30.2, 1,0)
individuals_removed_for_no_migratory_steps <- unique(amwo_hmm$ID [amwo_hmm$min.step == 1])
amwo_hmm <- amwo_hmm[(amwo_hmm$ID %in% amwo_hmm$ID [amwo_hmm$min.step == 1]) , ]
amwo_hmm$min.step <- NULL
```

if the month of the last > 16.1 km movement is 6 or later, then use
a 2 state model. If not, use the three state model
```{r}
# last_big_step_dates <- amwo_hmm %>%
#   filter(step > 16.1) %>%
#   group_by(ID) %>%
#   summarize(last_big_step = max(time))
# 
# nrow(last_big_step_dates) == length(unique(amwo_hmm$ID)) #check that there's a last big step date for all IDs
# 
# amwo_hmm <- amwo_hmm %>%
#   left_join(last_big_step_dates)
# 
# amwo_hmm2 <- amwo_hmm %>%
#   filter(month(last_big_step) >= 6)
# 
# amwo_hmm3 <- amwo_hmm %>%
#   filter(month(last_big_step) < 6)
```

Alternative method: if the mean of the last 5 steps is > 16.1 km, use the 2 state. Else use the 3 state.
Currently depreciated
```{r}
# last_step_means <- amwo_hmm %>%
#   group_by(ID) %>%
#   group_modify(function(x, ...){tail(x, n = 11)}) %>% ###
#   summarize(mean_final_steps = mean(step, na.rm = TRUE))
# 
# amwo_hmm <- amwo_hmm %>%
#   left_join(last_step_means)
# 
# amwo_hmm2 <- amwo_hmm %>%
#   filter(mean_final_steps > 16.1)
# 
# amwo_hmm3 <- amwo_hmm %>%
#   filter(mean_final_steps <= 16.1)

amwo_hmm3 <- amwo_hmm
```


Add the two state here

Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates3 <- amwo_hmm3 %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>%
  mutate(known = ifelse(ranks == "1", 1, NA)) %>%
  pull(known)
```

##### trying 3-state model with fixed state transitions

Label states and create distributions for movements
```{r}
stateNames3 <- c("pre","migration", "post")
nsim3 <- 25 # number of simulations
dist3 <- list(step="gamma", angle="wrpcauchy")# , pts_10mi_log = "norm", lat_diff_abs = "gamma"
```

fix step length parameters and state transitions
```{r}
fixPar3 <- list(beta=matrix(c(NA, -100, # pre-migration to transitions, can't go pre- to post
                     -100, NA,  #once entered migration can't go back to pre
                     -100, -100,
                     NA, -100,
                     -100, NA,
                     -100, -100), nrow = 2, byrow = TRUE)) #once entered post-migration, can't leave

```

These serve as the starting parameters for the HMM to optimize. Liam note: ask Erik where these came from
```{r}
#Default
# Par0_m1_3 <- list(step=c(0.485, 211.927, 0.485, #mean in km
#                        0.7327, 289.599, 0.7327, # SD in km
#                        0.026, 0.036, 0.026), #zeromass ie how many zeroes expected in the distribution
#                 angle=c(0, 0, 0, #mean
#                         0.5, 0.5, 0.5), #concentration
#                 julian_day = c(20, 50, 140, #mean 100
#                         10, 10, 30))

#Informed priors
Par0_m1_3 <- list(step=c(0.36553000, 57.96369562, 0.20293436, #mean in km
                       0.48229603, 140.73763264, 0.26933843, # SD in km
                       0.01593086, 0.02918066, 0.08298248), #zeromass ie how many zeroes expected in the distribution
                angle=c(-3.1360643, 3.0924885, -3.1388950, #mean
                        0.5024427, 0.2242694, 0.4235424), #concentration
                julian_day = c(20, 50, 140, #mean 100
                        10, 10, 30))


```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict3 <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=3, dist=dist3, Par0 = Par0_m1_3,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar3,
               #knownStates = knownStates,
               formula = ~julian_day, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames3, nsim = nsim3)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){return(1)} else{#for the first row, return 1
      if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
        return(1)
      } else{
        if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
          return(.x[i,"step_state"])
        } else{
          if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig
            return(1) 
          } else{ #in all other circumstances, return the current step state
            return(.x[i,"step_state"])
          }
        }
      }
    }
  }) %>% unlist()
  
  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r}
results_initial3 <- fit_and_predict3(amwo_hmm3) #results_initial includes both the created model and the df with predicted states 

#results_initial$model #probabilities of transition
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm3 <- results_initial3$results
```

This is the point where I rejoin amwo_hmm2 and amwo_hmm3 into a single amwo_hmm. The code continues as normal from here
```{r}
amwo_hmm <- amwo_hmm3 
```

The ruleset fails to designate a summering location for VA-2019-46 and SC-2019-03 due to late settlement (not enough points in the area before 6/30). If the window was longer it would correct this, but throw off other observations due to post-breeding dispersal movements. I'll manually force VA-2019-46 and SC-2019-03's final locations into state 3 instead.
```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(step_state = ifelse(animal_name == "VA-2019-46" & date == "2020-06-28", 3, step_state),
         point_state = ifelse(animal_name == "VA-2019-46" & date == "2020-06-28", 3, point_state)) %>%
  mutate(step_state = ifelse(animal_name == "SC-2019-03" & date == "2019-06-28", 3, step_state),
         point_state = ifelse(animal_name == "SC-2019-03" & date == "2019-06-28", 3, point_state))
```


Ruleset: Pre-migration is all points up until the bird departs > 16.1km from its initial location for the final time
```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  first_loc <- amwo_hmm %>%
    filter(ID == ind) %>%
    head(n = 1) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)

  amwo_ind <- amwo_hmm %>%
    filter(ID == ind) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
    mutate(condition_distance_km_pre = as.numeric(st_distance(geometry, first_loc))/1000) %>%
    st_drop_geometry() %>%
    mutate(within_dist_pre = condition_distance_km_pre < 16.1) #10
  
  amwo_ind <- amwo_ind %>%
    mutate(row_num = 1:nrow(amwo_ind))
  
  highest_premig_row <- amwo_ind %>%
    filter(within_dist_pre == 1) %>%
    pull(row_num) %>%
    max()
  
  if(highest_premig_row < -1000){
    cat(crayon::magenta("no points within 16.1 kilometers of the centroid"))
  }
  
  amwo_ind <- amwo_ind %>% 
    mutate(point_state = if_else(row_num <= highest_premig_row, 1 , point_state)) %>% #point_state_premig_corrected
    mutate(condition_distance_km_pre = NULL,
           within_dist_pre = NULL,
           row_num = NULL)
}) %>%
  exec("bind_rows", .)

```

Ruleset: Post-migration is all points up until the bird comes within 8km of its final location for the first time, assuming that its final location is in state 3
```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  last_loc <- amwo_hmm %>%
    filter(ID == ind) %>%
    tail(n = 1) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
  
  amwo_ind <- amwo_hmm %>%
    filter(ID == ind) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
    mutate(condition_distance_km_post = as.numeric(st_distance(geometry, last_loc))/1000) %>%
    st_drop_geometry() %>%
    mutate(within_dist_post = condition_distance_km_post < 8) #16.1
  
  amwo_ind <- amwo_ind %>%
    mutate(row_num = 1:nrow(amwo_ind))
  
  lowest_postmig_row <- amwo_ind %>%
    filter(within_dist_post == 1) %>%
    pull(row_num) %>%
    min()
  
  if(lowest_postmig_row< -1000){
    cat(crayon::magenta("no points within 8 kilometers of the last point"))
  }
  
  if(last_loc$point_state == 3){
    amwo_ind <- amwo_ind %>% 
      mutate(point_state = if_else(row_num >= lowest_postmig_row, 3 , point_state)) %>% 
      mutate(within_dist_post = NULL, 
        condition_distance_km_post = NULL,
        row_num = NULL)
  } else {
    amwo_ind <- amwo_ind %>% 
      mutate(within_dist_post = NULL, 
        condition_distance_km_post = NULL,
        row_num = NULL)
  }

  return(amwo_ind)
}) %>%
  exec("bind_rows", .)
```

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
Gonna try not doing this, as all I really care about are the migratory initiation dates
```{r}
# early_spring_movement %>%
#   mutate(step_state = 1, point_state = 1) ->
#   early_spring_movement
# 
# amwo_hmm %>%
#   rbind(early_spring_movement) ->
#   amwo_hmm
```

Correct step state based on the new point states
If:
- This point state is migratory
or
- there is a change in point state between this and the next i
then the state is migratory. otherwise, it is equal to the current point state

if we're on the last row for the individual, skip this determination and return NA

```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  #print(ind)
  amwo_ind <- amwo_hmm %>%
    filter(ID == ind)
  
  ind_vect <- c()
  
  for(i in 1:(nrow(amwo_ind)-1)){
    #print(i)
    if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
      ind_vect <- append(ind_vect, 2)
    } else {
      ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
    }
  }
  
  ind_vect <- append(ind_vect, NA)
  
  amwo_ind$step_state <- ind_vect
  return(amwo_ind)
}) %>%
  exec("bind_rows", .)
```

Last bit: remove all of the false migrations
```{r}
amwo_hmm <- amwo_hmm %>%
  filter(ID != "NJ-2019-28-2020",
         ID != "NS-2019-02-2020",
         ID != "RI-2020-42-2021")
```

```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm, file = "spring_female_3_state_model.rds")
```



