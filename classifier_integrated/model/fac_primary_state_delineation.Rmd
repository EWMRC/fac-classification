---
title: "R Notebook"
output: html_notebook
---

```{r include = FALSE}
library(tidyverse)
library(move)
library(sf)
#library(furrr)
#plan(multisession)
```

```{r}
fall_classified <- readRDS(here::here("classifier_fall", "fall_all_4_state_model.rds"))
spring_male_classified <- readRDS(here::here("classifier_spring", "spring_male_5_state_model.rds"))
spring_female_classified <-readRDS(here::here("classifier_spring", "spring_female_4_state_model.rds"))
```

Pulling the migratory initiation and termination date-times
```{r}
fall_initiation_dates <- fall_classified %>%
  filter(step_state == 2) %>%
  group_by(ID) %>%
  group_modify(function(x, ...){head(x, n = 1)}) %>%
  dplyr::select(ID, animal_name, year, time) %>%
  rename(time_initiation = time)

fall_termination_dates <- fall_classified %>%
  filter(step_state == 4) %>%
  group_by(ID) %>%
  group_modify(function(x, ...){head(x, n = 1)}) %>%
  dplyr::select(ID, animal_name, year, time) %>%
  rename(time_termination = time)

spring_male_initiation_dates <- spring_male_classified %>%
  filter(step_state == 2) %>%
  group_by(ID) %>%
  group_modify(function(x, ...){head(x, n = 1)}) %>%
  dplyr::select(ID, animal_name, year, time) %>%
  rename(time_initiation = time)

spring_male_termination_dates <- spring_male_classified %>%
  filter(step_state == 4 | step_state == 5) %>%
  group_by(ID) %>%
  group_modify(function(x, ...){head(x, n = 1)}) %>%
  dplyr::select(ID, animal_name, year, time) %>%
  rename(time_termination = time)

spring_female_initiation_dates <- spring_female_classified %>%
  filter(step_state == 2) %>%
  group_by(ID) %>%
  group_modify(function(x, ...){head(x, n = 1)}) %>%
  dplyr::select(ID, animal_name, year, time) %>%
  rename(time_initiation = time) 

spring_female_termination_dates <- spring_female_classified %>%
  filter(step_state == 4) %>%
  group_by(ID) %>%
  group_modify(function(x, ...){head(x, n = 1)}) %>%
  dplyr::select(ID, animal_name, year, time) %>%
  rename(time_termination = time)

spring_initiation_dates <- bind_rows(spring_male_initiation_dates, spring_female_initiation_dates)
spring_termination_dates <- bind_rows(spring_male_termination_dates, spring_female_termination_dates)

fall_migration_dates <- full_join(fall_initiation_dates, fall_termination_dates) %>%
  ungroup()

spring_migration_dates <- full_join(spring_initiation_dates, spring_termination_dates) %>%
  ungroup()

fall_migration_dates <- fall_migration_dates %>%
  dplyr::select(animal_name, time_initiation, time_termination) %>%
  mutate(season = "Fall")

spring_migration_dates <- spring_migration_dates %>%
  dplyr::select(animal_name, time_initiation, time_termination) %>%
  mutate(season = "Spring")

migration_dates <- bind_rows(fall_migration_dates, spring_migration_dates)
```

Download Movebank data, limit to times before Aug 1 2022 (more recent seasons haven't been delineated yet)
```{r}
amwo_move <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", 
                             login = readRDS("movebank_credentials.rds"), 
                             removeDuplicatedTimestamps=TRUE)

amwo_data <- as.data.frame(amwo_move) %>%
  transmute(animal_name = local_identifier,
            time = timestamp,
            event_id = event_id,
            lat = location_lat,
            long = location_long) %>%
  filter(time < lubridate::mdy("8/1/2022"))
```

1) Join in a way that creates a duplicate record for each location and potential mig bout
2) Classify each record using the potential mig info
3) Arrange the states using an ordered factor, with "stationary" on the bottom
```{r}
amwo_data_w_duplicates <- amwo_data %>%
  left_join(migration_dates) #%>%
  # mutate(unk_init_flag = if_else(is.na(unk_init_flag), FALSE, unk_init_flag)) %>% # If there is no migratory movement associated with the invididual, set the unk_init_flag to FALSE so that the following script runs correctly
  # mutate(unk_term_flag = if_else(is.na(unk_term_flag), FALSE, unk_term_flag))

#step state
amwo_data_w_duplicates$primary_step_state <- amwo_data_w_duplicates %>%
  dplyr::select(time, time_initiation, time_termination, season) %>%
  pmap(.f = function(time, time_initiation, time_termination, season){
    step_state <- "Stationary"
    #Silently implied; if both time_initiation and time_termination are NA, remains Stationary
    
    if(is.na(time_initiation)){ #error handling: there should always be an initiation date
      stop("No inititation date")
    }
    
    if(is.na(time_termination)){ #If there is no termination date
      if(time >= time_initiation){ 
        step_state <- if_else(season == "Fall", "Migratory (fall)", "Migratory (spring)")
      }
    }
    
    if(!is.na(time_termination)){ #If there is a termination date
      if(time >= time_initiation & time < time_termination){ 
        step_state <- if_else(season == "Fall", "Migratory (fall)", "Migratory (spring)")
      }
    }
    return(step_state)
  }) %>%
  unlist() %>%
  factor(levels = c("Migratory (spring)", "Migratory (fall)", "Stationary"), ordered = TRUE)

#point state
amwo_data_w_duplicates$primary_point_state <- amwo_data_w_duplicates %>%
  dplyr::select(time, time_initiation, time_termination, season) %>%
  pmap(.f = function(time, time_initiation, time_termination, season){
    point_state <- "Stationary"
    #Silently implied; if both time_initiation and time_termination are NA, remains Stationary
    
    if(is.na(time_initiation)){ #error handling: there should always be an initiation date
      stop("No inititation date")
    }
    
    if(is.na(time_termination)){ #If there is no termination date
      if(time > time_initiation){ 
        point_state <- if_else(season == "Fall", "Migratory (fall)", "Migratory (spring)")
      }
    }
    
    if(!is.na(time_termination)){ #If there is a termination date
      if(time > time_initiation & time < time_termination){
        point_state <- if_else(season == "Fall", "Migratory (fall)", "Migratory (spring)")
      }
    }
    
    
    return(point_state)
  }) %>%
  unlist() %>%
  factor(levels = c("Migratory (spring)", "Migratory (fall)", "Stationary"), ordered = TRUE)
```

4) Use head on records, grouped by event_id, to keep only the "top" record from each group. If there was any migratory movement during that time period, the top record will be a migratory state. If not, the top record will be a stationary state
```{r}
amwo_data_reconstructed <- amwo_data_w_duplicates %>%
  group_by(event_id) %>%
  arrange(primary_step_state, .by_group = TRUE) %>%
  group_modify(.f = function(x, ...){head(x, n = 1)}) %>% 
  dplyr::select(-season, -time_initiation, -time_termination) %>%
  ungroup()
```

Arrange by animal_id and time to ensure that the tracks graph correctly
```{r}
amwo_data_reconstructed <- amwo_data_reconstructed %>%
  group_by(animal_name) %>%
  arrange(time, .by_group = TRUE) %>%
  ungroup()
```

Set any bugged tracks to "Unknown- bugged frequent schedule"
```{r}
amwo_data_reconstructed <- amwo_data_reconstructed %>%
  mutate(primary_step_state = if_else(animal_name == "VT-2020-01" | animal_name == "VT-2020-02" | animal_name == "VT-2020-03" | animal_name == "VT-2020-04" | animal_name == "VT-2020-12", "Unknown- bugged frequent schedule", as.character(primary_step_state)),
         primary_point_state = if_else(animal_name == "VT-2020-01" | animal_name == "VT-2020-02" | animal_name == "VT-2020-03" | animal_name == "VT-2020-04" | animal_name == "VT-2020-12", "Unknown- bugged frequent schedule", as.character(primary_point_state)))
```

```{r}
saveRDS(amwo_data_reconstructed, file = here::here("classifier_integrated", "fac_primary_state_delineation.rds"))
```
