---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---
```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Load data
```{r}
load(file=here("classifier_spring", "spring_male_data.RData"))
```

Certain birds have a single pre-mig location before they migrate. Define those birds so that I can auto-classify their states as mig during classification, and stick them correctly into pre-mig in the after-classification editing
```{r}
RI_problems <- c("AL-2022-20-2022", "NJ-2018-03-2019", "QUE-2020-17-2021", "RI-2019-24-2020", "VT-2021-27-2022")
```

Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>%
  mutate(known = ifelse(ranks == "1", 1, NA)) %>%
  mutate(known = ifelse(ID == "NC-2021-25-2021" & julian_day == 139, 2, known)) %>% 
  mutate(known = ifelse(ID == "VT-2020-05-2021" & julian_day == 99, 2, known)) %>% 
  mutate(known = ifelse(known == 1 & ID %in% RI_problems, 2, known)) %>% 
  pull(known)
```

##### trying 5-state model

Label states and create distributions for movements
```{r}
stateNames <- c("pre", "migration", "stopover", "settling", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", log_mean_dist_7 = "norm", residence_time = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern") #, lat_diff_abs = "gamma" , pts_10mi_log = "norm"
```

fix step length parameters and state transitions
```{r}
fixPar <- list(beta=matrix(c(NA,	-10000,	-10000,	-10000,	
                             -10000,	NA,	NA,	NA,	
                             -10000,	NA,	-10000, -10000, 
                             -10000, -10000, -10000, NA, 
                             -10000,	-10000,	-10000,	NA), nrow = 1, byrow = TRUE),
               step_500 = c(0.000000001, 0.999999999, 0.000000001, 0.000000001, 0.000000001)) 
```

These serve as the starting parameters for the HMM to optimize.
```{r}
Par0_m1 <- list(step=c(0.293641627, 79.029506936, 0.157361645, 0.250739740, 0.086056474, #mean in km
                       0.455493251, 95.302307236, 0.211421668, 0.384581337, 0.128558113, # SD in km
                       0.005159307, 0.006024863, 0.006664064, 0.005636388, 0.006973284), #zeromass ie how many zeroes expected in the distribution
                angle=c(0.001353412, 0.0006979447, 0.01168102, 0.0005445842, 0, #mean
                        0.917280917, 0.9754146876, 0.59501513, 0.7614896594, 0.99999), #concentration
                y = c(34.83030, 40.173268, 40.426752,  44.689995, 43.678101,
                      3.11158, 4.497807, 3.668652, 2.267504, 4.109156),
                julian_day = c(40.14297, 79.36682, 80.54528, 135.69949, 136.7710, #mean
                        19.89502, 27.50774, 23.92289, 25.77254, 30.0146),
                log_mean_dist_7 = c(4.126427, 9.965601, 4.959182, 3.797415, 3.581605, #mean
                                1.679125, 2.403601, 2.736004, 1.536724, 1.806670), #sd
                residence_time = c(39.91826, 6.848351, 53.64592, 71.41284, 70.66562, #mean
                                   20.41741, 13.174650, 35.49282, 21.65228, 25.53273), #sd
                dist_start = c(0.00530222, 0.9276614, 0.9750638, 0.9955032, 0.9882519), #prob
                step_500 = c(0.1336989, 0.99999, 0.06175472, 0.1351401, 0.04079765), #prob
                breeding_abundance = c(0.1183127, 0.3973247, 0.442492, 0.7108834, 0.5959887)) #prob
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=5, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               #userBounds = userBounds,
               #workBounds = workBounds,
               #DM = DM,
               knownStates = knownStates,
               #formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){
      return(1) #for the first row, return 1
    } else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
      return(1)
    } else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
      return(.x[i,"step_state"])
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1 & .x[i,"ID"] == .x[i-1,"ID"]){ #is the current step state mig and the previous step pre-mig, and is this not step 1? Return pre-mig
      return(1)
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
      return(3)
    } else{ #in all other circumstances, return the current step state
      return(.x[i,"step_state"])
    }
    
  }) %>% unlist()
  
  #Fix the RI problem birds
  .x <- .x %>% 
    group_by(ID) %>%
    mutate(ranks = row_number()) %>%
    mutate(point_state = ifelse(ranks == "1" & ID %in% RI_problems, 1, point_state)) %>% 
    ungroup() %>% 
    dplyr::select(-ranks)
  
  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r}
start_time <- Sys.time()
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states 
end_time <- Sys.time()
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm_final <- results_initial$results

results_initial$model #probabilities of transition

print(start_time)
print(end_time)
```

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
```{r}
summer_transient_movement %>%
  mutate(step_state = c(rep(5,10), NA), point_state = 5) ->
  summer_transient_movement

amwo_hmm_final %>%
  rbind(summer_transient_movement) ->
  amwo_hmm_final
```

Ruleset: If the total step distance between the end of 1 and the 1st 3 is less than 30.2 km, then everything until the last 3 in that sequence is 1
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, y){
    iter_df <- iter_df %>%
      mutate(., row_num = 1:nrow(.))

    first_30km_step <- iter_df %>%
      filter(step > 30.2) %>%
      pull(row_num) %>%
      min(na.rm = TRUE)

    iter_df %>%
      mutate(point_state = if_else(row_num <= first_30km_step, 1, point_state),
             step_state = if_else(row_num < first_30km_step, 1, as.numeric(step_state))) %>%
      return()

  }) %>%
  ungroup() %>%
  mutate(row_num = NULL)
```

Ruleset: If the total step distance between the start of 4 and the most recent 3 is less than 30.2 km, then everything from the top of the most recent 3 down is 4
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, y){
    final_state <- pull(tail(iter_df, 1), point_state)
    if(final_state == 4 | final_state == 5){ #if the last point is in a final state, all locations after the last 30.2 km movement are also in a final state
      iter_df <- iter_df %>%
        mutate(., row_num = 1:nrow(.))

      last_30km_step <- iter_df %>%
        filter(step > 30.2) %>%
        pull(row_num) %>%
        max(na.rm = TRUE)

      iter_df <- iter_df %>%
        mutate(point_state = if_else(row_num > last_30km_step & (point_state %in% c(1,2,3)), 4, point_state),
               step_state = if_else(row_num > last_30km_step & (point_state %in% c(1,2,3)), 4, step_state))
    }
    return(iter_df)
  }) %>%
  ungroup() %>%
  mutate(row_num = NULL)
```

Correct step state based on the new point states
If:
- This point state is migratory
or
- there is a change in point state between this and the next i
then the state is migratory. otherwise, it is equal to the current point state

if we're on the last row for the individual, skip this determination and return NA
Broken for the 4 state model, I haven't bothered to try to replace it yet
```{r}
# amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
#   #print(ind)
#   amwo_ind <- amwo_hmm %>%
#     filter(ID == ind)
#   
#   ind_vect <- c()
#   
#   for(i in 1:(nrow(amwo_ind)-1)){
#     #print(i)
#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#   
#   ind_vect <- append(ind_vect, NA)
#   
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
```

Last bit: remove all of the false migrations
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  filter(ID != "RI-2019-21-2020",
         ID != "RI-2019-28-2020",
         ID != "RI-2019-29-2020",
         ID != "VA-2018-03-2018")
         #ID != "RI-2019-18-2020")
```

```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm_final to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here("classifier_spring", "spring_male_5_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_spring", "spring_male_5_state_parameters.rds"))
```



