---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

This is a streamlined version of what Erik originally wrote in momentuHMM_amwo_Spring_Male2. Uses HMMs to determine if birds settle after migration, and then uses a ruleset to define when each state starts and stops

Last bit: remove all of the false migrations

```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
```

Extract all locations from 2019, 2020, and 2021 from Jan 5th through June 30th
```{r include=FALSE}
login <- movebankLogin(username = "LA_Berigan", password="33szcNUtv4iyPGU")
amwo_2018 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20180105000000000", timestamp_end = "20180630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2019 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20190105000000000", timestamp_end = "20190630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2020 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20200105000000000", timestamp_end = "20200630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2021 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20210105000000000", timestamp_end = "20210630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2022 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20220105000000000", timestamp_end = "20220630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
```

Formatting and cleaning, including creating time columns and simplifying to one location per day
```{r}
amwo_spring <- as.data.frame(rbind(amwo_2018, amwo_2019, amwo_2020, amwo_2021, amwo_2022))

amwo_spring <- amwo_spring %>%
  transmute(ID = local_identifier,
            #time = as.POSIXct(round(force_tzs(timestamp, tzone = "GMT", tzone_out = "EST"), "hour")), #time rounded in EST
            time = timestamp,
            lon = location_long,
            lat = location_lat,
            tagtype = comments,
            sex = sex,
            age = taxon_detail,
            altitude = height_above_msl)

amwo_spring <- amwo_spring %>%
  mutate(t = strftime(time, format="%H:%M"),
         date = strftime(time, format="%Y-%m-%d")) #%>%
  #distinct(date, ID, .keep_all = TRUE) # remove multiple locations on same day, mainly retaining only 1 of 3 locations 1st day after marking
```

Converting all age classes to juvenile and adult
```{r}
amwo_spring <- amwo_spring %>%
  mutate(age = recode_factor(age,
                             "Second Year" = "juv",
                             "Hatch Year" = "juv",
                             "After Hatch Year" = "ad",
                             "After Second Year" = "ad",
                             "Third Year" = "ad",
                             "After Third Year" = "ad"))
```

Extracting tag type, schedule, state marked, and year
```{r}
amwo_spring <- amwo_spring %>%
  separate(tagtype, c("tagtype", "second", "schedule"), sep = " ") %>% 
  dplyr::select(-second) %>%
  mutate(ID2 = ID) %>%
  separate(ID2, c("m.state", "m.year", "third"), sep = "-") %>% 
  dplyr::select(-third)
```

Filtering to just females and individuals with unknown sex
```{r}
amwo_spring_males <- amwo_spring %>%
  filter(sex == "f" | sex == "")
```

Account for potential duplicate years by adding a year to the end of the id
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(year = strftime(time, format="%Y")) %>%
  mutate(animal_name = ID,
         ID = paste(ID, year, sep="-"))
```

Add a julian day column (new data stream)
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(julian_day = yday(ymd(date)))
```

Remove individuals with fewer than 3 locations, recording which ones were removed
```{r}
individuals_removed_for_too_few_locations <- amwo_spring_males %>%
  group_by(ID) %>%
  tally() %>%
  filter(n < 3) %>%
  pull(ID)

birds_to_keep <- amwo_spring_males %>%
  group_by(ID) %>%
  tally() %>%
  filter(n > 2) %>%
  pull(ID)

amwo_spring_males <- amwo_spring_males %>%
  filter(ID %in% birds_to_keep)
```

Flag individuals tagged after February 15th on the year of observation so that I can mark their initial stationary state as uncertain
```{r include = FALSE}
# Comment this out if running repeatedly; otherwise it will just slow down the code
# googledrive::as_id("https://drive.google.com/file/d/19JA5OztH3hS4MPfVnH5zswDxSSLcWxL3/view?usp=sharing") %>%
#         googledrive::drive_download(path = here("capture_sheet.xlsx"), overwrite = TRUE)

capture_dates <- readxl::read_excel(here("capture_sheet.xlsx"), col_types = c("text", "text", "date", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text")) %>%
        mutate(`Argos_ID` = as.character(`Argos_ID`)) %>%
  transmute(animal_name = `Movebank_ID`,
            capture_date = Date)

individuals_tagged_too_late <- amwo_spring_males %>%
  left_join(capture_dates) %>%
  filter((year == year(capture_date) & mdy(paste0("2/15/", year)) < capture_date)) %>% #remove locations when the bird was caught after Oct 15 in the year of concern
  dplyr::select(ID, animal_name, year) %>%
  distinct()
```

Flag individuals which died before May 15th on the year of observation so that I can mark their final stationary state as uncertain. Don't worry about the 2020 thing, it's just a standardized year.

### This will bias any survival analyses done with these designations ###
```{r}
individuals_died_too_early <- amwo_spring_males %>%
  group_by(ID) %>%
  summarise(max_time = max(time)) %>%
  mutate(max_date = mdy(paste0(month(max_time), "/", day(max_time), "/2020"))) %>%
  filter(max_date < mdy("5/15/2020")) %>%
  pull(ID)
```


Crawl code goes here
```{r include=FALSE}
# Group tracks by id (for crawl model because it likes tidyverse structure)
nested_birds <- group_by(amwo_spring_males, ID) %>% 
  nest() 

# Movement model (no covariates = ~1)
# The constraints are based on the godwit example
# Fit model to each bird. Constrain velocity autoregression parameter to c(-7,2)
# full effective range of the beta parameter (according to D Johnson)
nested_birds <- mutate(nested_birds,
                fit = purrr::map(data, ~{crawl::crwMLE(mov.model=~1, 
                                                       data=.x, 
                                                       coord=c("lon", "lat"), # movement model = ~1 bc no covariates
                                                       Time.name="time",
                                                       #time.scale='hours', # sometimes need to turn this on, sometimes don't
                                                       method="L-BFGS-B", # there are different optimization methods, default didn't work but this did
                                                       constr=list(lower=c(-Inf,-7), upper=c(Inf,2)),
                                                       attempts=20,
                                                       time.scale = "hours")}
                )
)

nested_birds <- mutate(nested_birds,
                pred = purrr::map(fit, ~{
                  crawl::crwPredict(.x, predTime="24 hours", return.type='flat') %>% # use 24 hours, NOT 1 day (because it rounds to the unit)
                    crawl::crw_as_tibble()
                }
                )
)

unnested_birds <- dplyr::select(nested_birds, ID, pred) %>% unnest(cols=pred)
```

# create momentuHMMData object; would specify covariates if included in the dataset
##  basically the step length and turn angles are now included
## Also create a data stream for difference in latitude (may be necessary for a ruleset: if not, remove)
```{r}
# amwo_hmm <- amwo_spring_males %>%
#   rename(x = lon, y = lat) 

amwo_hmm <- unnested_birds %>%
  rename(x = mu.x, y = mu.y) %>% 
  ungroup()

#remove duplicates by date to deal with predicted locations on the same day as the observed location
amwo_hmm <- amwo_hmm %>% 
  mutate(date = strftime(time, format="%Y-%m-%d")) %>% 
  distinct(date, ID, .keep_all = TRUE) %>% 
  mutate(julian_day = yday(ymd(date))) #Redo the julian day calculation

amwo_hmm$lat_diff <- map(1:nrow(amwo_hmm),  function(i){
  if(i == 1){return(NA)} else{#for the first row, return 1
    if(amwo_hmm[i,"ID"] != amwo_hmm[i-1,"ID"]){ #is this the first point for this ID? Return NA
      return(NA)
    } else{
      return(amwo_hmm[i,"y"] - amwo_hmm[i-1,"y"])
    }
  }
}) %>% unlist()

amwo_hmm <- amwo_hmm %>%
  mutate(lat_diff_abs = abs(lat_diff)) %>% 
  dplyr::select(ID, animal_name, year, locType, x, y, time, date, julian_day) %>% 
  as.data.frame()
  
```

Determine the mean distance to the nearest 7 points
```{r}
plan(multisession)

amwo_hmm$mean_dist_7 <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter)
    
    st_distance(x = iter_sf, y = other_locs) %>% 
      as.numeric() %>%
      sort() %>%
      .[2:8] %>% 
      mean(na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```


```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(log_mean_dist_7 = log(mean_dist_7 + 0.1)) %>% #Adding a small # to deal with 0 distances 
  prepData(type = "LL") %>% #, covNames = c("julian_day", "log_mean_dist_7")
  mutate(step = round(step, digits = 2))
```


#remove early spring movements which throw off the hmm for NJ-2018-08-2019, NJ-2018-13-2019, and NJ-2018-15-2019. Add it back again at the end as a manually-delineated residential movement at the end (or not, as this code only cares about delineating state-shift dates)
```{r}
# early_spring_movement <- amwo_hmm %>%
#   mutate(id_time = paste(ID, as.character(time))) %>%
#   filter(id_time == "VA-2020-52-2020 2020-06-18 21:00:00" | id_time == "VA-2020-52-2020 2020-06-28 14:00:00") %>%
#   mutate(id_time = NULL)

early_spring_movement <- amwo_hmm %>%
  filter((ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32")) |
         (ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-14 00:00:00")) |
         (ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-05 00:00:00")))

amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32"))) %>%
  filter(!(ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-14 00:00:00"))) %>%
  filter(!(ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-05 00:00:00")))

#additionally trimming RI-2020-31; I won't add it back in (not necessary for this workflow). Algorithm catches the tail end of fall migration and pushes it into spring mig too early.
amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "RI-2020-31-2021" & time <= ymd_hms("2021-03-02 18:59:12")))

```

remove birds with no individual step lengths >30.2km (20 miles). In practice this pulls birds that never initiate a substantial migratory movement but doesn't penalize birds that DO migrate, as they always make at least one substantial movement.
Also recording which individuals are removed
```{r}
amwo_hmm$min.step <- ifelse(amwo_hmm$step > 30.2, 1, 0)
individuals_removed_for_no_migratory_steps <- unique(amwo_hmm$ID [amwo_hmm$min.step == 1])
amwo_hmm <- amwo_hmm[(amwo_hmm$ID %in% amwo_hmm$ID [amwo_hmm$min.step == 1]) , ]
amwo_hmm$min.step <- NULL
```

Alternative method: if the mean of the last 5 steps is > 16.1 km, use the 2 state. Else use the 3 state.
Currently depreciated, so all birds use the three state
```{r}
amwo_hmm3 <- amwo_hmm
```

Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates3 <- amwo_hmm3 %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>%
  mutate(known = ifelse(ranks == "1", 1, NA)) %>%
  pull(known)
```

##### trying 3-state model with fixed state transitions

Label states and create distributions for movements
```{r}
stateNames3 <- c("pre","migration", "post")
dist3 <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", log_mean_dist_7 = "norm")# , pts_10mi_log = "norm", lat_diff_abs = "gamma"
```

fix step length parameters and state transitions
```{r}
fixPar3 <- list(beta=matrix(c(NA, -100, # pre-migration to transitions, can't go pre- to post
                     -100, NA,  #once entered migration can't go back to pre
                     -100, -100), nrow = 1, byrow = TRUE)) #once entered post-migration, can't leave
```

These serve as the starting parameters for the HMM to optimize.
```{r}
#Default
# Par0_m1_3 <- list(step=c(0.485, 211.927, 0.485, #mean in km
#                        0.7327, 289.599, 0.7327, # SD in km
#                        0.026, 0.036, 0.026), #zeromass ie how many zeroes expected in the distribution
#                 angle=c(0, 0, 0, #mean
#                         0.5, 0.5, 0.5), #concentration
#                 julian_day = c(20, 50, 140, #mean 100
#                         10, 10, 30))

#Informed priors
Par0_m1_3 <- list(step=c(0.36553000, 57.96369562, 0.20293436, #mean in km
                       0.48229603, 140.73763264, 0.26933843, # SD in km
                       0.01593086, 0.02918066, 0.08298248), #zeromass ie how many zeroes expected in the distribution
                angle=c(-3.1360643, 3.0924885, -3.1388950, #mean
                        0.5024427, 0.2242694, 0.4235424), #concentration
                y = c(34.32931, 36.79636, 41.58981,
                      2.398324,4.035114, 4.433215),
                julian_day = c(20, 50, 140, #mean 100
                        10, 10, 30),
                log_mean_dist_7 = c(log(100), log(5000), log(100), #mean
                                log(50), log(20), log(50)))


```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict3 <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=3, dist=dist3, Par0 = Par0_m1_3,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar3,
               #knownStates = knownStates,
               #formula = ~julian_day + log_mean_dist_7, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames3)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){return(1)} else{#for the first row, return 1
      if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
        return(1)
      } else{
        if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
          return(.x[i,"step_state"])
        } else{
          if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig
            return(1) 
          } else{ #in all other circumstances, return the current step state
            return(.x[i,"step_state"])
          }
        }
      }
    }
  }) %>% unlist()
  
  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r}
results_initial3 <- fit_and_predict3(amwo_hmm3) #results_initial includes both the created model and the df with predicted states 

results_initial3$model #probabilities of transition
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm3 <- results_initial3$results
```

This is the point where I rejoin amwo_hmm2 and amwo_hmm3 into a single amwo_hmm. The code continues as normal from here
Depreciated
```{r}
amwo_hmm <- amwo_hmm3 
```

The ruleset fails to designate a summering location for VA-2019-46 and SC-2019-03 due to late settlement (not enough points in the area before 6/30). If the window was longer it would correct this, but throw off other observations due to post-breeding dispersal movements. I'll manually force VA-2019-46 and SC-2019-03's final locations into state 3 instead.
## NOTE: CRW may change this, so i'm commenting out for now. Will put them back in on a case-by-case basis
```{r}
# amwo_hmm <- amwo_hmm %>%
#   mutate(step_state = ifelse(animal_name == "VA-2019-46" & date == "2020-06-28", 3, step_state),
#          point_state = ifelse(animal_name == "VA-2019-46" & date == "2020-06-28", 3, point_state)) %>%
#   mutate(step_state = ifelse(animal_name == "SC-2019-03" & date == "2019-06-28", 3, step_state),
#          point_state = ifelse(animal_name == "SC-2019-03" & date == "2019-06-28", 3, point_state))
```

Ruleset: Pre-migration is all points up until the bird departs > 16.1km from its initial location for the final time
```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  first_loc <- amwo_hmm %>%
    filter(ID == ind) %>%
    head(n = 1) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)

  amwo_ind <- amwo_hmm %>%
    filter(ID == ind) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
    mutate(condition_distance_km_pre = as.numeric(st_distance(geometry, first_loc))/1000) %>%
    st_drop_geometry() %>%
    mutate(within_dist_pre = condition_distance_km_pre < 16.1) #10
  
  amwo_ind <- amwo_ind %>%
    mutate(row_num = 1:nrow(amwo_ind))
  
  highest_premig_row <- amwo_ind %>%
    filter(within_dist_pre == 1) %>%
    pull(row_num) %>%
    max()
  
  if(highest_premig_row < -1000){
    cat(crayon::magenta("no points within 16.1 kilometers of the centroid"))
  }
  
  amwo_ind <- amwo_ind %>% 
    mutate(point_state = if_else(row_num <= highest_premig_row, 1 , point_state)) %>% #point_state_premig_corrected
    mutate(condition_distance_km_pre = NULL,
           within_dist_pre = NULL,
           row_num = NULL)
}) %>%
  exec("bind_rows", .)

```

Ruleset: Post-migration is all points up until the bird comes within 8km of its final location for the first time, assuming that its final location is in state 3
```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  last_loc <- amwo_hmm %>%
    filter(ID == ind) %>%
    tail(n = 1) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
  
  amwo_ind <- amwo_hmm %>%
    filter(ID == ind) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
    mutate(condition_distance_km_post = as.numeric(st_distance(geometry, last_loc))/1000) %>%
    st_drop_geometry() %>%
    mutate(within_dist_post = condition_distance_km_post < 8) #16.1
  
  amwo_ind <- amwo_ind %>%
    mutate(row_num = 1:nrow(amwo_ind))
  
  lowest_postmig_row <- amwo_ind %>%
    filter(within_dist_post == 1) %>%
    pull(row_num) %>%
    min()
  
  if(lowest_postmig_row< -1000){
    cat(crayon::magenta("no points within 8 kilometers of the last point"))
  }
  
  if(last_loc$point_state == 3){
    amwo_ind <- amwo_ind %>% 
      mutate(point_state = if_else(row_num >= lowest_postmig_row, 3 , point_state)) %>% 
      mutate(within_dist_post = NULL, 
        condition_distance_km_post = NULL,
        row_num = NULL)
  } else {
    amwo_ind <- amwo_ind %>% 
      mutate(within_dist_post = NULL, 
        condition_distance_km_post = NULL,
        row_num = NULL)
  }

  return(amwo_ind)
}) %>%
  exec("bind_rows", .)
```

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
Gonna try not doing this, as all I really care about are the migratory initiation dates
```{r}
# early_spring_movement %>%
#   mutate(step_state = 1, point_state = 1) ->
#   early_spring_movement
# 
# amwo_hmm %>%
#   rbind(early_spring_movement) ->
#   amwo_hmm
```

Correct step state based on the new point states
If:
- This point state is migratory
or
- there is a change in point state between this and the next i
then the state is migratory. otherwise, it is equal to the current point state

if we're on the last row for the individual, skip this determination and return NA

```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  #print(ind)
  amwo_ind <- amwo_hmm %>%
    filter(ID == ind)
  
  ind_vect <- c()
  
  for(i in 1:(nrow(amwo_ind)-1)){
    #print(i)
    if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
      ind_vect <- append(ind_vect, 2)
    } else {
      ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
    }
  }
  
  ind_vect <- append(ind_vect, NA)
  
  amwo_ind$step_state <- ind_vect
  return(amwo_ind)
}) %>%
  exec("bind_rows", .)
```

Last bit: remove all of the false migrations
```{r}
amwo_hmm <- amwo_hmm %>%
  filter(ID != "NJ-2019-28-2020",
         ID != "NS-2019-02-2020",
         ID != "RI-2020-42-2021")
```

```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm, file = here::here("classifier_spring", "spring_female_3_state_model.rds"))
```


