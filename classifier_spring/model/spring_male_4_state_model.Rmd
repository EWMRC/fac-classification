---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

This is a streamlined version of what Erik originally wrote in momentuHMM_amwo_Spring_Male2. Uses HMMs to determine if birds settle after migration, and then uses a ruleset to define when each state starts and stops

Last bit: remove all of the false migrations

```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Extract all locations from 2019, 2020, and 2021 from Jan 5th through June 30th
```{r include=FALSE}
login <- movebankLogin(username = "LA_Berigan", password="33szcNUtv4iyPGU")
amwo_2018 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20180105000000000", timestamp_end = "20180630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2019 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20190105000000000", timestamp_end = "20190630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2020 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20200105000000000", timestamp_end = "20200630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2021 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20210105000000000", timestamp_end = "20210630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2022 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20220105000000000", timestamp_end = "20220630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
```

Formatting and cleaning, including creating time columns and simplifying to one location per day
```{r}
amwo_spring <- as.data.frame(rbind(amwo_2018, amwo_2019, amwo_2020, amwo_2021, amwo_2022))

amwo_spring <- amwo_spring %>%
  transmute(ID = local_identifier,
            #time = as.POSIXct(round(force_tzs(timestamp, tzone = "GMT", tzone_out = "EST"), "hour")), #time rounded in EST
            time = timestamp,
            lon = location_long,
            lat = location_lat,
            tagtype = comments,
            sex = sex,
            age = taxon_detail,
            altitude = height_above_msl)

amwo_spring <- amwo_spring %>%
  mutate(t = strftime(time, format="%H:%M"),
         date = strftime(time, format="%Y-%m-%d")) #%>%
  #distinct(date, ID, .keep_all = TRUE) # remove multiple locations on same day, mainly retaining only 1 of 3 locations 1st day after marking
```

Converting all age classes to juvenile and adult
```{r}
amwo_spring <- amwo_spring %>%
  mutate(age = recode_factor(age,
                             "Second Year" = "juv",
                             "Hatch Year" = "juv",
                             "After Hatch Year" = "ad",
                             "After Second Year" = "ad",
                             "Third Year" = "ad",
                             "After Third Year" = "ad"))
```

Extracting tag type, schedule, state marked, and year
```{r}
amwo_spring <- amwo_spring %>%
  separate(tagtype, c("tagtype", "second", "schedule"), sep = " ") %>% 
  dplyr::select(-second) %>%
  mutate(ID2 = ID) %>%
  separate(ID2, c("m.state", "m.year", "third"), sep = "-") %>% 
  dplyr::select(-third)
```

Filtering to just males
```{r}
amwo_spring_males <- amwo_spring %>%
  filter(sex == "m")
```

Account for potential duplicate years by adding a year to the end of the id
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(year = strftime(time, format="%Y")) %>%
  mutate(animal_name = ID,
         ID = paste(ID, year, sep="-"))
```

Add a julian day column (new data stream)
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(julian_day = yday(ymd(date)))
```

Remove individuals with fewer than 3 locations, recording which ones were removed
```{r}
individuals_removed_for_too_few_locations <- amwo_spring_males %>%
  distinct(ID, date,.keep_all = TRUE) %>% 
  group_by(ID) %>%
  tally() %>% 
  filter(n < 3) %>%
  pull(ID)

birds_to_keep <- amwo_spring_males %>%
  distinct(ID, date,.keep_all = TRUE) %>% 
  group_by(ID) %>%
  tally() %>%
  filter(n > 2) %>%
  pull(ID)

amwo_spring_males <- amwo_spring_males %>%
  filter(ID %in% birds_to_keep)
```

Flag individuals tagged after February 15th on the year of observation so that I can mark their initial stationary state as uncertain
```{r include = FALSE}
# Comment this out if running repeatedly; otherwise it will just slow down the code
# googledrive::as_id("https://drive.google.com/file/d/19JA5OztH3hS4MPfVnH5zswDxSSLcWxL3/view?usp=sharing") %>%
#         googledrive::drive_download(path = here("capture_sheet.xlsx"), overwrite = TRUE)

capture_dates <- readxl::read_excel(here("capture_sheet.xlsx"), col_types = c("text", "text", "date", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text")) %>%
        mutate(`Argos_ID` = as.character(`Argos_ID`)) %>%
  transmute(animal_name = `Movebank_ID`,
            capture_date = Date)

individuals_tagged_too_late <- amwo_spring_males %>%
  left_join(capture_dates) %>%
  filter((year == year(capture_date) & mdy(paste0("2/15/", year)) < capture_date)) %>% #remove locations when the bird was caught after Feb 15 in the year of concern
  dplyr::select(ID, animal_name, year) %>%
  distinct()
```

Flag individuals which died before May 15th on the year of observation so that I can mark their final stationary state as uncertain. 

### This will bias any survival analyses done with these designations ###
```{r}
individuals_died_too_early <- amwo_spring_males %>%
  group_by(ID) %>%
  summarise(max_time = max(time)) %>%
  mutate(max_date = mdy(paste0(month(max_time), "/", day(max_time), "/2020"))) %>%
  filter(max_date < mdy("5/15/2020")) %>%
  pull(ID)
```

Crawl code goes here 
First parameter is sigma, second is beta (autocorrelation) rnorm(200,-4,2)
```{r include=FALSE}
# Group tracks by id (for crawl model because it likes tidyverse structure)
nested_birds <- group_by(amwo_spring_males, ID) %>% 
  nest() 

# Movement model (no covariates = ~1)
# The constraints are based on the godwit example
# Fit model to each bird. Constrain velocity autoregression parameter to c(-7,2)
# full effective range of the beta parameter (according to D Johnson)
nested_birds <- mutate(nested_birds,
                fit = purrr::map(data, ~{crawl::crwMLE(mov.model=~1, 
                                                       data=.x, 
                                                       coord=c("lon", "lat"), # movement model = ~1 bc no covariates
                                                       Time.name="time",
                                                       #time.scale='hours', # sometimes need to turn this on, sometimes don't
                                                       method="L-BFGS-B", # there are different optimization methods, default didn't work but this did
                                                       constr=list(lower=c(-Inf,-7), upper=c(Inf,2)),
                                                       attempts=20,
                                                       time.scale = "hours")}
                )
)

nested_birds <- mutate(nested_birds,
                pred = purrr::map(fit, ~{
                  crawl::crwPredict(.x, predTime="24 hours", return.type='flat') %>% # use 24 hours, NOT 1 day (because it rounds to the unit)
                    crawl::crw_as_tibble()
                }
                )
)

unnested_birds <- dplyr::select(nested_birds, ID, pred) %>% unnest(cols=pred)
```


# create momentuHMMData object; would specify covariates if included in the dataset
##  basically the step length and turn angles are now included
## Also create a data stream for difference in latitude (may be necessary for a ruleset: if not, remove)
```{r}
# amwo_hmm <- amwo_spring_males %>%
#   rename(x = lon, y = lat) 
amwo_hmm <- unnested_birds %>%
  rename(x = mu.x, y = mu.y) %>% 
  ungroup()

#remove duplicates by date to deal with predicted locations on the same day as the observed location
#amwo_hmm <- amwo_hmm %>% 
amwo_hmm <- amwo_hmm %>% 
  mutate(date = strftime(time, format="%Y-%m-%d"),
         locType = factor(locType, levels = c("o", "p"), ordered = TRUE)) %>%
  arrange(ID, date, locType) %>% #keep observed locations above predicted locations
  distinct(ID, date, .keep_all = TRUE) %>% 
  mutate(julian_day = yday(ymd(date))) #Redo the julian day calculation
  
amwo_hmm$lat_diff <- map(1:nrow(amwo_hmm),  function(i){
  if(i == 1){return(NA)} else{#for the first row, return 1
    if(amwo_hmm[i,"ID"] != amwo_hmm[i-1,"ID"]){ #is this the first point for this ID? Return NA
      return(NA)
    } else{
      return(amwo_hmm[i,"y"] - amwo_hmm[i-1,"y"])
    }
  }
}) %>% unlist()

amwo_hmm <- amwo_hmm %>%
  mutate(lat_diff_abs = abs(lat_diff)) %>% 
  dplyr::select(ID, animal_name, year, locType, x, y, time, date, julian_day) %>% 
  as.data.frame()
  
```

Identify loops produced by the crawl and replace them with evenly-spaced points
```{r include = FALSE}
plan(multisession)
nested_birds_2 <- amwo_hmm %>%
  group_by(ID) %>%
  nest()

nested_birds_2$data <- nested_birds_2 %>% 
  pull(data) %>% 
  future_map(.f = function(x){

    x <- x %>% 
      mutate(., rownum = 1:nrow(.))
    
    #Transform to 5070 so I can interpolate points
    x_coords <- x %>%
      st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
      st_transform(5070) %>% 
      st_coordinates() %>% 
      as.data.frame()
    
    x$x <- x_coords$X
    x$y <- x_coords$Y
    
    observed_locs <- x %>%
      filter(locType == "o")
    
    for(i in 1:(nrow(observed_locs)-1)){
      #print(i)
      point_1 <- observed_locs[i,] %>%
        st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
      
      point_2 <- observed_locs[i + 1,] %>%
        st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
      
      point_dist <- st_distance(point_1, point_2,) %>%
        as.numeric(.)
      
      total_dist <- x[c(point_1$rownum, point_1$rownum:point_2$rownum),] %>%
        as.data.frame() %>% 
        prepData(type = "UTM") %>%
        pull(step) %>%
        sum(na.rm = TRUE)
      
      if(total_dist > (10*point_dist)){ #if the total step distance is more than 10 times the distance between observed points, replace with equally spaced between the points
        x_step <- (point_2$x - point_1$x)/(point_2$rownum - point_1$rownum)
        y_step <- (point_2$y - point_1$y)/(point_2$rownum - point_1$rownum)
        for(j in (point_1$rownum+1):(point_2$rownum-1)){
          #paste("Row number:", j) %>%  print()
          loop_index <- j - point_1$rownum
          
          #paste("Initial x:", x$x[j]) %>%  print()
          x$x[j] <- x$x[point_1$rownum] + (x_step*loop_index)
          #paste("Final x:", x$x[j]) %>%  print()
          
          #paste("Initial y:", x$y[j]) %>%  print()
          x$y[j] <- x$y[point_1$rownum] + (y_step*loop_index)
          #paste("Final y:", x$y[j]) %>%  print()
        }
      } 
    }
    #Cleanup
    x$rownum <- NULL
    
    #transform back to 4326
    x_coords <- x %>%
      st_as_sf(coords = c("x", "y"), crs = 5070) %>% 
      st_transform(4326) %>% 
      st_coordinates() %>% 
      as.data.frame()
    
    x$x <- x_coords$X
    x$y <- x_coords$Y
    
    return(x)
  })

amwo_hmm <- nested_birds_2 %>% 
  unnest(cols = c(data))

plan(sequential)
```

Determine the mean distance to the nearest 7 points
```{r}
plan(multisession)

amwo_hmm$mean_dist_7 <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter)
    
    st_distance(x = iter_sf, y = other_locs) %>% 
      as.numeric() %>%
      sort() %>%
      .[2:8] %>% 
      mean(na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```

Determining the amount of time that the bird has spent/will spend within a 10km radius of the point
```{r}
plan(multisession)
amwo_hmm$residence_time <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>% 
      st_transform(5070) %>% 
      st_buffer(10000) %>% #10 km radius
      transmute(intersection = 1)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter) %>% 
      st_transform(5070) %>% 
      transmute(date = ymd(date))
    
    intersected_locs <- other_locs %>% 
      st_join(iter_sf) %>% 
      filter(intersection == 1)
    
    as.numeric(max(intersected_locs$date, na.rm = TRUE) - min(intersected_locs$date), na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```

Determining the log distance from the first point to the current point
```{r}
plan(multisession)

nested_birds_3 <- amwo_hmm %>%
  group_by(ID) %>%
  nest()

nested_birds_3$data <- nested_birds_3 %>% 
  pull(data) %>% 
  future_map(.f = function(int){
    
    int <- int %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
    
    dist_vect <- st_distance(x = int[1,], y = int, by_element = FALSE) %>% #results in meters
      as.numeric() #NOTE: NEEDS sf 1.0-9 to work correctly
    
    # dist_vect <- log(dist_vect + 1.1)
    dist_vect <- if_else(dist_vect < 16100, 0, 1)
    
    int <- int %>% 
      st_drop_geometry() %>% 
      mutate(dist_start = dist_vect)
    
    return(int)
  })

amwo_hmm <- nested_birds_3 %>% 
  unnest(cols = c(data))

plan(sequential)

```


```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(log_mean_dist_7 = log(mean_dist_7 + 0.1)) %>% #Adding a small # to deal with 0 distances
  as.data.frame() %>% 
  prepData(type = "LL") %>% #, covNames = c("julian_day", "log_mean_dist_7")
  mutate(step = round(step, digits = 4))  #round down to a tenth of a meter, which is higher than our GPS precision
```


remove a transient summer movement which throws off the hmm for VA-2020-52-2020. Add it back again at the end as a manually-delineated residential movement at the end
```{r}
summer_transient_movement <- amwo_hmm %>%
  filter(ID == "VA-2020-52-2020" & julian_day > 160)
  #mutate(id_time = paste(ID, as.character(time))) %>% 
  #filter(id_time == "VA-2020-52-2020 2020-06-19 01:59:28" | id_time == "VA-2020-52-2020 2020-06-28 19:01:20") %>%
  #mutate(id_time = NULL)

amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "VA-2020-52-2020" & julian_day > 160))
  # mutate(id_time = paste(ID, as.character(time))) %>% 
  # filter(id_time != "VA-2020-52-2020 2020-06-19 01:59:28") %>%
  # filter(id_time != "VA-2020-52-2020 2020-06-28 19:01:20") %>%
  # mutate(id_time = NULL)
```

remove birds with no individual step lengths >30.2km (20 miles). In practice this pulls birds that never initiate a substantial migratory movement but doesn't penalize birds that DO migrate, as they always make at least one substantial movement.
Also recording which individuals are removed
```{r}
amwo_hmm$min.step <- ifelse(amwo_hmm$step > 30.2, 1, 0)
individuals_removed_for_no_migratory_steps <- unique(amwo_hmm$ID [amwo_hmm$min.step == 1])
amwo_hmm <- amwo_hmm[(amwo_hmm$ID %in% amwo_hmm$ID [amwo_hmm$min.step == 1]) , ]
amwo_hmm$min.step <- NULL
```

Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>%
  mutate(known = ifelse(ranks == "1", 1, NA)) %>%
  pull(known)
```

##### trying 5-state model

Label states and create distributions for movements
```{r}
stateNames <- c("pre", "migration", "stopover", "settling", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", log_mean_dist_7 = "norm", residence_time = "norm", dist_start = "bern") #, lat_diff_abs = "gamma" , pts_10mi_log = "norm"
```

fix step length parameters and state transitions
```{r}
fixPar <- list(beta=matrix(c(NA,	-1000,	-1000,	-1000,	-1000,	NA,	NA,	NA,	-1000,	NA,	-1000,	-1000,	-1000,	-1000,	-1000,	NA,	-1000,	-1000,	-1000,	NA), nrow = 1, byrow = TRUE))

#, dist_start = c(NA, NA, 14.023368, 14.023368, 14.023368,
#NA, NA, 1, 1, 1)

#Estimate the dist_start of pre-mig and mig, but hold the dist_start of stopover, settling, and post-mig to be identical) #once entered post-migration, can't leave
```

Set design matricies for certain data streams
```{r include=FALSE}
# DM_step <- matrix(c(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0, #identity
#                     0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
#                     0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
#                     0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
#                     0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
#                     0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
#                     0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
#                     0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
#                     0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
#                     0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,
#                     0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,
#                     0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
#                     0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
#                     0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
#                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,1),
#                   dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5", "z1", "z2", "z3", "z4", "z5"),
#                                   c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5", "z1", "z2", "z3", "z4", "z5")),
#                   nrow = 15, ncol = 15, byrow=TRUE)

# DM_y <- matrix(c(1,0,0,0,0,0,0,0,0,0, #1 must always be at lower latitudes than 2 & 3, and 2&3 must always come before 4&5
#                  1,1,1,0,0,0,0,0,0,0, #gonna switch this up for fall
#                  1,1,1,0,0,0,0,0,0,0,
#                  1,1,1,1,1,0,0,0,0,0,
#                  1,1,1,1,1,0,0,0,0,0,
#                  0,0,0,0,0,1,0,0,0,0,
#                  0,0,0,0,0,0,1,0,0,0,
#                  0,0,0,0,0,0,0,1,0,0,
#                  0,0,0,0,0,0,0,0,1,0,
#                  0,0,0,0,0,0,0,0,0,1),
#                dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"),
#                                c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5")),
#                nrow = 10, ncol = 10, byrow=TRUE)

# DM_julian_day <- matrix(c(1,0,0,0,0,0,0,0,0,0, #1 must always come before 2 & 3, and 2&3 must always come before 4&5
#                           1,1,1,0,0,0,0,0,0,0,
#                           1,1,1,0,0,0,0,0,0,0,
#                           1,1,1,1,1,0,0,0,0,0,
#                           1,1,1,1,1,0,0,0,0,0,
#                           0,0,0,0,0,1,0,0,0,0,
#                           0,0,0,0,0,0,1,0,0,0,
#                           0,0,0,0,0,0,0,1,0,0,
#                           0,0,0,0,0,0,0,0,1,0,
#                           0,0,0,0,0,0,0,0,0,1),
#                         dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"),
#                                         c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5")),
#                         nrow = 10, ncol = 10, byrow=TRUE)

# DM_residence_time <- matrix(c(1,0,0,0,0,0,0,0,0,0, #identity
#                               0,1,0,0,0,0,0,0,0,0,
#                               0,0,1,0,0,0,0,0,0,0,
#                               0,0,0,1,0,0,0,0,0,0,
#                               0,0,0,0,1,0,0,0,0,0,
#                               0,0,0,0,0,1,0,0,0,0,
#                               0,0,0,0,0,0,1,0,0,0,
#                               0,0,0,0,0,0,0,1,0,0,
#                               0,0,0,0,0,0,0,0,1,0,
#                               0,0,0,0,0,0,0,0,0,1),
#                             dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"),
#                                             c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5")),
#                             nrow = 10, ncol = 10, byrow=TRUE)

# DM_dist_start <- matrix(c(1,0,0,0,0,0,0,0,0,0, #estimate the means for 2, 3, 4, and 5 together, and 1 separately
#                           1,1,1,1,1,0,0,0,0,0,
#                           1,1,1,1,1,0,0,0,0,0,
#                           1,1,1,1,1,0,0,0,0,0,
#                           1,1,1,1,1,0,0,0,0,0,
#                           0,0,0,0,0,1,0,0,0,0,
#                           0,0,0,0,0,0,1,0,0,0,
#                           0,0,0,0,0,0,0,1,0,0,
#                           0,0,0,0,0,0,0,0,1,1,
#                           0,0,0,0,0,0,0,0,1,1),
#                         dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"),
#                                         c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5")),
#                         nrow = 10, ncol = 10, byrow=TRUE)
# 
# DM <- list(step = DM_step)#,
#            #y = DM_y,
#            #julian_day = DM_julian_day,
#            #residence_time = DM_residence_time,
#            #dist_start = DM_dist_start)

```

Set boundaries for the working parameters (e.g. the columns in the design matrix) and the user parameters (the rows)
```{r include=FALSE}
# workbounds_step <- matrix(c(-Inf, Inf, #if you want to ensure that some means are larger than others, this is what you edit
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf,
#                             -Inf, Inf),
#                           dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5", "z1", "z2", "z3", "z4", "z5"), 
#                                           c("lower", "upper")), 
# #                           nrow = 15, ncol = 2, byrow=TRUE)
# 
# userbounds_step <- matrix(c(0, 5, #slow steps should not average higher than 0.5 km
#                             0, 200,
#                             0, 5,
#                             0, 5,
#                             0, 5,
#                             0, 5,
#                             0, 200,
#                             0, 5,
#                             0, 5,
#                             0, 5,
#                             0, 1,
#                             0, 1,
#                             0, 1,
#                             0, 1,
#                             0, 1),
#                           dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5", "z1", "z2", "z3", "z4", "z5"), 
#                                           c("lower", "upper")), 
#                           nrow = 15, ncol = 2, byrow=TRUE)

# workbounds_y <- matrix(c(-Inf, Inf, 
#                          0, Inf, #set subsequent covariates to be positive so that they're additive
#                          0, Inf,
#                          0, Inf,
#                          0, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf),
#                        dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"), 
#                                        c("lower", "upper")), 
#                        nrow = 10, ncol = 2, byrow=TRUE)

# userbounds_y <- matrix(c(-Inf, Inf, 
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf,
#                          -Inf, Inf),
#                        dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"), 
#                                        c("lower", "upper")), 
#                        nrow = 10, ncol = 2, byrow=TRUE)


# workbounds_julian_day <- matrix(c(-Inf, Inf, 
#                                   0, Inf, #set subsequent covariates to be positive so that they're additive
#                                   0, Inf,
#                                   0, Inf,
#                                   0, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf),
#                                 dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"), 
#                                                 c("lower", "upper")), 
#                                 nrow = 10, ncol = 2, byrow=TRUE)

# userbounds_julian_day <- matrix(c(-Inf, Inf, 
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf),
#                                 dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"), 
#                                                 c("lower", "upper")), 
#                                 nrow = 10, ncol = 2, byrow=TRUE)

# workbounds_dist_start <- matrix(c(-Inf, Inf, 
#                                   0, Inf, #set subsequent covariates to be positive so that they're additive
#                                   0, Inf,
#                                   0, Inf,
#                                   0, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf),
#                                 dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"), 
#                                                 c("lower", "upper")), 
#                                 nrow = 10, ncol = 2, byrow=TRUE)

# userbounds_dist_start <- matrix(c(-Inf, Inf, 
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf,
#                                   -Inf, Inf),
#                                 dimnames = list(c("m1", "m2","m3","m4", "m5", "s1", "s2", "s3", "s4", "s5"), 
#                                                 c("lower", "upper")), 
#                                 nrow = 10, ncol = 2, byrow=TRUE)

# workBounds <- list(#step = workbounds_step,
#                    y = workbounds_y,
#                    julian_day = workbounds_julian_day,
#                    dist_start = workbounds_dist_start
#                    )
# 
# userBounds <- list(step = userbounds_step)#,
#                    #y = userbounds_y,
#                    #julian_day = userbounds_julian_day,
#                    #dist_start = userbounds_dist_start
#                    
```


These serve as the starting parameters for the HMM to optimize.
```{r}
Par0_m1 <- list(step=c(0.485, 211.927, 0.485, 1, 0.285, #mean in km
                       0.7327, 289.599, 0.7327, 0.7327, 0.7327, # SD in km
                       0.026, 0.036, 0.026, 0.026, 0.026), #zeromass ie how many zeroes expected in the distribution
                angle=c(0, 0, 0, 0, 0, #mean
                        0.5, 0.5, 0.5, 0.5, 0.5), #concentration
                y = c(34.32931, 36.79636, 36.79636,  41.58981, 41.58981,
                      2.398324, 4.035114, 4.035114, 4.433215, 4.433215),
                julian_day = c(39.19987, 79.72239, 79.72239, 136.54740, 136.54740, #mean
                        18.71277, 20.65775, 20.65775, 22.94372, 22.94372),
                log_mean_dist_7 = c(log(100), log(5000), log(100), log(100), log(100), #mean
                                log(50), log(20), log(50), log(50), log(50)), #sd
                residence_time = c(40.2, 7.39, 55.9, 70.6, 70.6, #mean
                                   21.6, 16.4, 32.0, 21.3, 21.3), #sd
                dist_start = c(0.1, 0.9, 0.9, 0.9, 0.9)) 
                # lat_diff_abs = c(0.01, 1, 0.01,
                #                  0.01, 1, 0.01,
                #                  0.026, 0.036, 0.026)) 
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=5, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               #userBounds = userBounds,
               #workBounds = workBounds,
               #DM = DM,
               #knownStates = knownStates,
               #formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){
      return(1) #for the first row, return 1
    } else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
      return(1)
    } else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
      return(.x[i,"step_state"])
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig
      return(1) 
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
      return(3) 
    } else{ #in all other circumstances, return the current step state
      return(.x[i,"step_state"])
    }
    
  }) %>% unlist()
  
  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r}
start_time <- Sys.time()
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states 
end_time <- Sys.time()
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm_final <- results_initial$results

results_initial$model #probabilities of transition

print(start_time)
print(end_time)
```

Ruleset: If the total step distance between the start of 4 and the most recent 3 is less than 2 km, then everything from the top of the most recent 3 down is 4

# Phasing out for the 5 state

```{r}
# amwo_hmm_final <- amwo_hmm_final %>% 
#   group_by(ID) %>% 
#   group_modify(function(iter_df, ...){
#     iter_df <- iter_df %>% 
#       mutate(., row_num = 1:nrow(.))
#     
#     if(any(iter_df$point_state == 3) & any(iter_df$point_state == 4)){
#       first_4_row <- iter_df %>% 
#         filter(point_state == 4) %>% 
#         pull(row_num) %>% 
#         min()
#       
#       last_3_row <- iter_df %>% 
#         filter(point_state == 3) %>% 
#         pull(row_num) %>% 
#         max()
#       
#       total_dist_moved <- iter_df[last_3_row:(first_4_row-1), "step"] %>% 
#         sum()
#       
#       if(total_dist_moved < 2){
#         start_of_last_stopover <- iter_df[1:(last_3_row-1),] %>% 
#           filter(point_state == 2) %>%
#           pull(row_num) %>% 
#           max(.) + 1
#         
#         iter_df[start_of_last_stopover:nrow(iter_df), "point_state"] <- 4
#       }
#     }
#     return(iter_df)
#   }) %>% 
#   ungroup() %>% 
#   mutate(row_num = NULL)
```


Ruleset: Pre-migration is all points up until the bird departs > 16.1km from its initial location for the final time
```{r}
# amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
#   first_loc <- amwo_hmm_final %>%
#     filter(ID == ind) %>%
#     head(n = 1) %>%
#     st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
# 
#   amwo_ind <- amwo_hmm_final %>%
#     filter(ID == ind) %>%
#     st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
#     mutate(condition_distance_km_pre = as.numeric(st_distance(geometry, first_loc))/1000) %>%
#     st_drop_geometry() %>%
#     mutate(within_dist_pre = condition_distance_km_pre < 16.1) #10
#   
#   amwo_ind <- amwo_ind %>%
#     mutate(row_num = 1:nrow(amwo_ind))
#   
#   highest_premig_row <- amwo_ind %>%
#     filter(within_dist_pre == 1) %>%
#     pull(row_num) %>%
#     max()
#   
#   if(highest_premig_row < -1000){
#     cat(crayon::magenta("no points within 16.1 kilometers of the centroid"))
#   }
#   
#   amwo_ind <- amwo_ind %>% 
#     mutate(point_state = if_else(row_num <= highest_premig_row, 1 , point_state)) %>% #point_state_premig_corrected
#     mutate(condition_distance_km_pre = NULL,
#            within_dist_pre = NULL,
#            row_num = NULL)
# }) %>%
#   exec("bind_rows", .)

```

Ruleset: Post-migration is all points up until the bird comes within 8km of its final location for the first time, assuming that its final location is in state 4
```{r}
# amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
#   last_loc <- amwo_hmm_final %>%
#     filter(ID == ind) %>%
#     tail(n = 1) %>%
#     st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
#   
#   amwo_ind <- amwo_hmm_final %>%
#     filter(ID == ind) %>%
#     st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
#     mutate(condition_distance_km_post = as.numeric(st_distance(geometry, last_loc))/1000) %>%
#     st_drop_geometry() %>%
#     mutate(within_dist_post = condition_distance_km_post < 8) #16.1
#   
#   amwo_ind <- amwo_ind %>%
#     mutate(row_num = 1:nrow(amwo_ind))
#   
#   lowest_postmig_row <- amwo_ind %>%
#     filter(within_dist_post == 1) %>%
#     pull(row_num) %>%
#     min()
#   
#   if(lowest_postmig_row< -1000){
#     cat(crayon::magenta("no points within 8 kilometers of the last point"))
#   }
#   
#   if(last_loc$point_state == 4){
#     amwo_ind <- amwo_ind %>% 
#       mutate(point_state = if_else(row_num >= lowest_postmig_row, 4, point_state)) %>% 
#       mutate(within_dist_post = NULL, 
#         condition_distance_km_post = NULL,
#         row_num = NULL)
#   } else {
#     amwo_ind <- amwo_ind %>% 
#       mutate(within_dist_post = NULL, 
#         condition_distance_km_post = NULL,
#         row_num = NULL)
#   }
# 
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
```

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
```{r}
summer_transient_movement %>%
  mutate(step_state = c(rep(5,19), NA), point_state = 5) ->
  summer_transient_movement

amwo_hmm_final %>%
  rbind(summer_transient_movement) ->
  amwo_hmm_final
```

Manually fix a bug: if a point is in pre-mig, all of the prior points must also have been pre-mig
```{r}
# amwo_hmm_final <- amwo_hmm_final %>% 
#   group_by(ID) %>% 
#   group_modify(function(x, ...){
#     most_recent_premig <- x %>% 
#       filter(point_state == 1) %>% 
#       pull(date) %>% 
#       ymd() %>% 
#       max()
#     
#     x %>% 
#       mutate(point_state = if_else(ymd(date) < most_recent_premig, 1, point_state)) %>% 
#       return()
#   }) %>% 
#   ungroup()
```



Correct step state based on the new point states
If:
- This point state is migratory
or
- there is a change in point state between this and the next i
then the state is migratory. otherwise, it is equal to the current point state

if we're on the last row for the individual, skip this determination and return NA
Broken for the 4 state model, I haven't bothered to try to replace it yet
```{r}
# amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
#   #print(ind)
#   amwo_ind <- amwo_hmm %>%
#     filter(ID == ind)
#   
#   ind_vect <- c()
#   
#   for(i in 1:(nrow(amwo_ind)-1)){
#     #print(i)
#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#   
#   ind_vect <- append(ind_vect, NA)
#   
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
```

Last bit: remove all of the false migrations
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  filter(ID != "RI-2019-21-2020",
         ID != "RI-2019-28-2020",
         ID != "RI-2019-29-2020",
         ID != "VA-2018-03-2018")
         #ID != "RI-2019-18-2020")
```

```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm_final to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here("classifier_spring", "spring_male_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_spring", "spring_male_4_state_parameters.rds"))
```



