---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---
```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Load data for use in the model
```{r}
load(file=here("classifier_spring", "spring_female_data.RData"))
```

Define those birds for which I should estimate starting states (birds tagged in VA, NJ, or MD in this season)
Defining "tagged this season" as "tagged less than 2 months (~60 days) before the first location of this seasonal delineation"
```{r}
starting_state_key <- amwo_hmm %>% #How many days before the first location of the season was this bird captured?
  left_join(capture_dates) %>% 
  group_by(ID) %>% 
  nest() %>%
  mutate(days_from_capture_to_first_loc = map(.x = data, .f = function(iter_df){
    first_time <- iter_df %>% 
      head(n = 1) %>% 
      pull(time)
    
    cap_date <- iter_df %>% 
      head(n = 1) %>% 
      pull(capture_date)
    
    as.numeric(first_time - cap_date)/24 %>% #diff time is in hours, convert to days
      return()
  }))

starting_state_key <- starting_state_key %>% 
  mutate(estimate_starting_state = if_else((str_detect(ID, pattern = "VA") | str_detect(ID, pattern = "NJ") | str_detect(ID, pattern = "MD")) & days_from_capture_to_first_loc < 60, true = TRUE, false = FALSE)) %>% 
  mutate(estimate_starting_state = if_else(ID %in% c("NJ-2018-13-2019", "NJ-2018-15-2019"), true = FALSE, false = estimate_starting_state)) %>% #Two birds were tagged in Dec, but didn't start taking points until much later, which causes the estimator to push them into mig as an initial states
  dplyr::select(ID, estimate_starting_state) %>% 
  ungroup()

amwo_hmm <- amwo_hmm %>% 
  left_join(starting_state_key)
```

Assign a starting state for each individual
This looks clunky, but it's necessary to maintain a momentuHMMData class
I should be able to take many of the individual exceptions after these changes
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
known_state_key <- amwo_hmm %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>% # rank observations (requires correct sorting), ifelse to convert first observations to state 1 and all others NA
  ungroup() %>% 
  mutate(known = ifelse(estimate_starting_state == FALSE & ranks == 1, yes = 1, no = NA)) %>%
  mutate(r1p1s2 = if_else(known == 1 & step > 30.2, true = TRUE, false = FALSE)) %>% #if known == 1 and step >30.2, mark as a "rank 1 point 1 step 2" event to be reclassified in post-processing
  mutate(r1p1s2 = replace_na(r1p1s2, replace = FALSE)) %>% #deals with NA issues
  mutate(known = ifelse(step > 30.2, 2, known)) %>% #if step length is >30.2, then it must be mig (even if known is already 1) 
  #mutate(known = ifelse(ID == "VA-2021-91-2021" & ranks %in% c(16, 17, 18), 2, known)) %>% #This seems to be a holdover from an old model. Remove
  #mutate(known = ifelse(ID == "VA-2021-92-2021" & ranks %in% c(6, 7, 8), 2, known)) %>% #This seems to be a holdover from an old model. Remove
  #mutate(known = ifelse(ID == "NJ-2018-15-2019" & julian_day == 46, 2, known)) %>% #This seems to be a holdover from an old model. Remove
  #mutate(known = ifelse(ID == "VA-2019-22-2019" & julian_day == 99, 2, known)) %>% #This seems to be a holdover from an old model (but unclear). Remove
  #mutate(known = ifelse(ID == "ME-2018-13-2019" & julian_day == 161, 2, known)) %>% #This seems to be a holdover from an old model. Remove
  mutate(known = ifelse(ID == "NY-2022-40-2022" & ranks == 1, 3, known)) %>%  #bird that migrated after nesting starts in stopover state
  mutate(known = ifelse(ID == "RI-2018-11-2019" & ranks == 95, 4, known)) #bird is recaptured and re-transmittered at the last mig location the following Oct, so we know that it is settled here

amwo_hmm$known <- known_state_key$known
amwo_hmm$r1p1s2 <- known_state_key$r1p1s2

knownStates <- amwo_hmm$known
```

##### trying 5-state model

Label states and create distributions for movements
```{r}
stateNames <- c("pre", "migration", "stopover", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern", log_mean_dist_7 = "norm", residence_time = "norm") #,  
```

fix step length parameters and state transitions
```{r}
fixPar <- list(beta=matrix(c(NA, -1000,	-1000,	-1000,	NA,	NA,	-1000,	NA,	-1000,	-1000,	-1000,	-1000), nrow = 1, byrow = TRUE),
               step_500 = c(0.000000001, 0.999999999, 0.000000001, 0.000000001)) 
```

These serve as the starting parameters for the HMM to optimize.
```{r}
Par0_m1 <- list(step=c(0.260832696, 9.429288e+01, 0.323209095, 0.1581120, #mean in km
                       0.434046082, 9.829083e+01, 0.565636024 , 0.2682378, # SD in km
                       0.002864053, 1.549953e-09, 0.008935152, 0.0101826), #zeromass ie how many zeroes expected in the distribution
                angle=c(0.001212793, -0.004443658, -0.004534878, 0.0003999368, #mean
                        0.882238488, 0.911903062, 0.405040026, 0.7535390314),
                y = c(35.142723, 40.642156, 41.012048,  44.801910,
                      2.567658, 4.407258, 3.666311, 3.010217),
                julian_day = c(41.63823, 86.00518, 88.73997, 141.08671, #mean
                               20.60346, 26.04991, 25.50664, 23.33606),#concentration
                log_mean_dist_7 = c(3.601858, 9.920471, 4.539150, 3.114167, #mean
                                    1.610840, 2.643817, 2.938573, 1.637662), #sd
                residence_time = c(49.87944, 7.546966, 26.48728, 66.52459, #mean
                                   21.66159, 16.575491, 20.09901, 22.88829), #sd
                dist_start = c(0.01667985, 0.9264421, 0.9762556, 0.999999), #prob
                step_500 = c(0.002299856, 0.99999, 7.443581e-09, 0.00255622), #prob
                breeding_abundance = c(0.1159913, 0.4453295, 0.5308599, 0.8146863)) #prob
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=4, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               #userBounds = userBounds,
               #workBounds = workBounds,
               #DM = DM,
               knownStates = knownStates,
               #formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){
      return(.x[i,"step_state"]) 
    } else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
      return(.x[i,"step_state"]) 
    } else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
      return(.x[i,"step_state"])
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig 
      return(1) 
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
      return(3)
    } else{ #in all other circumstances, return the current step state
      return(.x[i,"step_state"])
    }
  }) %>% unlist()
  
  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r}
start_time <- Sys.time()
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states 
end_time <- Sys.time()
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm_final <- results_initial$results

results_initial$model #probabilities of transition

print(start_time)
print(end_time)
```

Fix the r1p1s2 issue
```{r}
amwo_hmm_final <- amwo_hmm_final %>% 
  mutate(point_state = if_else(r1p1s2 == TRUE, 1, point_state))
```

What is the starting state for any given classification?
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, y){
    iter_df$starting_state <- iter_df %>% 
      head(n = 1) %>% 
      pull(step_state)
    
    return(iter_df)
  }) %>% 
  ungroup()
```

Ruleset: If the total step distance between the end of 1 and the 1st 3 is less than 30.2 km, then everything until the last 3 in that sequence is 1. Adjusted to also fix step states.
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, y){
    iter_df <- iter_df %>%
      mutate(., row_num = 1:nrow(.))
    
    first_30km_step <- iter_df %>%
      filter(step > 30.2) %>%
      pull(row_num) %>%
      min(na.rm = TRUE)
    
    if(any(iter_df$starting_state == 1)){
      iter_df %>%
        mutate(point_state = if_else(row_num <= first_30km_step, 1, point_state),
               step_state = if_else(row_num < first_30km_step, 1, as.numeric(step_state))) %>%
        return()
    } else if (any(iter_df$starting_state == 2 | iter_df$starting_state == 3)){
      iter_df %>%
        return()
    } else {
      stop("Starting state is not 1, 2, or 3")
    }
    
  }) %>%
  ungroup() %>%
  mutate(row_num = NULL)
```

Ruleset: If the total step distance between the start of 4 and the most recent 3 is less than 30.2 km, then everything from the top of the most recent 3 down is 4
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, y){
    final_state <- pull(tail(iter_df, 1), point_state)
    if(final_state == 4){ #if the last point is in a final state, all locations after the last 30.2 km movement are also in a final state
      iter_df <- iter_df %>%
        mutate(., row_num = 1:nrow(.))
      
      last_30km_step <- iter_df %>%
        filter(step > 30.2) %>%
        pull(row_num) %>%
        max(na.rm = TRUE)
      
      iter_df <- iter_df %>%
        mutate(point_state = if_else(row_num > last_30km_step, 4, point_state),
               step_state = if_else(row_num > last_30km_step, 4, step_state))
    }
    return(iter_df)
  }) %>%
  ungroup() %>%
  mutate(row_num = NULL)
```

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
Gonna try not doing this, as all I really care about are the migratory initiation dates
```{r}
# early_spring_movement %>%
#   mutate(step_state = 1, point_state = 1) ->
#   early_spring_movement
# 
# amwo_hmm %>%
#   rbind(early_spring_movement) ->
#   amwo_hmm
```

Last bit: remove all of the false migrations
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  filter(ID != "NJ-2019-28-2020", # missing bird, exclude from paper
         ID != "NS-2019-02-2020", #tail end of a fall migration
         ID != "RI-2020-42-2021", #tail end of a fall migration
         ID != "RI-2021-47-2022", #tail end of fall migration
         ID != "RI-2021-52-2022") #Fall migration does not terminate
```

```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here::here("classifier_spring", "spring_female_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_spring", "spring_female_4_state_parameters.rds"))
```

