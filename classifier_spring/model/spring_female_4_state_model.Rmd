---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

This is a streamlined version of what Erik originally wrote in momentuHMM_amwo_Spring_Male2. Uses HMMs to determine if birds settle after migration, and then uses a ruleset to define when each state starts and stops

Last bit: remove all of the false migrations

```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Extract all locations from 2019, 2020, and 2021 from Jan 5th through June 30th
```{r include=FALSE}
login <- movebankLogin(username = "LA_Berigan", password="33szcNUtv4iyPGU")
amwo_2018 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20180105000000000", timestamp_end = "20180630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2019 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20190105000000000", timestamp_end = "20190630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2020 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20200105000000000", timestamp_end = "20200630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2021 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20210105000000000", timestamp_end = "20210630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2022 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20220105000000000", timestamp_end = "20220630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
```

Formatting and cleaning, including creating time columns and simplifying to one location per day
```{r}
amwo_spring <- as.data.frame(rbind(amwo_2018, amwo_2019, amwo_2020, amwo_2021, amwo_2022))

amwo_spring <- amwo_spring %>%
  transmute(ID = local_identifier,
            #time = as.POSIXct(round(force_tzs(timestamp, tzone = "GMT", tzone_out = "EST"), "hour")), #time rounded in EST
            time = timestamp,
            lon = location_long,
            lat = location_lat,
            tagtype = comments,
            sex = sex,
            age = taxon_detail,
            altitude = height_above_msl)

amwo_spring <- amwo_spring %>%
  mutate(t = strftime(time, format="%H:%M"),
         date = strftime(time, format="%Y-%m-%d")) #%>%
  #distinct(date, ID, .keep_all = TRUE) # remove multiple locations on same day, mainly retaining only 1 of 3 locations 1st day after marking
```

Converting all age classes to juvenile and adult
```{r}
amwo_spring <- amwo_spring %>%
  mutate(age = recode_factor(age,
                             "Second Year" = "juv",
                             "Hatch Year" = "juv",
                             "After Hatch Year" = "ad",
                             "After Second Year" = "ad",
                             "Third Year" = "ad",
                             "After Third Year" = "ad"))
```

Extracting tag type, schedule, state marked, and year
```{r}
amwo_spring <- amwo_spring %>%
  separate(tagtype, c("tagtype", "second", "schedule"), sep = " ") %>% 
  dplyr::select(-second) %>%
  mutate(ID2 = ID) %>%
  separate(ID2, c("m.state", "m.year", "third"), sep = "-") %>% 
  dplyr::select(-third)
```

Filtering to just females and individuals with unknown sex
```{r}
amwo_spring_males <- amwo_spring %>%
  filter(sex == "f" | sex == "")
```

Account for potential duplicate years by adding a year to the end of the id
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(year = strftime(time, format="%Y")) %>%
  mutate(animal_name = ID,
         ID = paste(ID, year, sep="-"))
```

Add a julian day column (new data stream)
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(julian_day = yday(ymd(date)))
```

Remove individuals with fewer than 3 locations, recording which ones were removed
```{r}
individuals_removed_for_too_few_locations <- amwo_spring_males %>%
  distinct(ID, date, .keep_all = TRUE) %>% 
  group_by(ID) %>%
  tally() %>%
  filter(n < 3) %>%
  pull(ID)

birds_to_keep <- amwo_spring_males %>%
  distinct(ID, date, .keep_all = TRUE) %>% 
  group_by(ID) %>%
  tally() %>%
  filter(n > 2) %>%
  pull(ID)

amwo_spring_males <- amwo_spring_males %>%
  filter(ID %in% birds_to_keep)
```

Flag individuals tagged after February 15th on the year of observation so that I can mark their initial stationary state as uncertain
```{r include = FALSE}
# Comment this out if running repeatedly; otherwise it will just slow down the code
# googledrive::as_id("https://drive.google.com/file/d/19JA5OztH3hS4MPfVnH5zswDxSSLcWxL3/view?usp=sharing") %>%
#         googledrive::drive_download(path = here("capture_sheet.xlsx"), overwrite = TRUE)

capture_dates <- readxl::read_excel(here("capture_sheet.xlsx"), col_types = c("text", "text", "date", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text")) %>%
        mutate(`Argos_ID` = as.character(`Argos_ID`)) %>%
  transmute(animal_name = `Movebank_ID`,
            capture_date = Date)

individuals_tagged_too_late <- amwo_spring_males %>%
  left_join(capture_dates) %>%
  filter((year == year(capture_date) & mdy(paste0("2/15/", year)) < capture_date)) %>% #remove locations when the bird was caught after Oct 15 in the year of concern
  dplyr::select(ID, animal_name, year) %>%
  distinct()
```

Flag individuals which died before May 15th on the year of observation so that I can mark their final stationary state as uncertain. Don't worry about the 2020 thing, it's just a standardized year.

### This will bias any survival analyses done with these designations ###
```{r}
individuals_died_too_early <- amwo_spring_males %>%
  group_by(ID) %>%
  summarise(max_time = max(time)) %>%
  mutate(max_date = mdy(paste0(month(max_time), "/", day(max_time), "/2020"))) %>%
  filter(max_date < mdy("5/15/2020")) %>%
  pull(ID)
```

Crawl code goes here
First parameter is sigma, second is beta (autocorrelation) rnorm(200,-4,2)
```{r include=FALSE}
# Group tracks by id (for crawl model because it likes tidyverse structure)
nested_birds <- group_by(amwo_spring_males, ID) %>% 
  nest() 

# Movement model (no covariates = ~1)
# The constraints are based on the godwit example
# Fit model to each bird. Constrain velocity autoregression parameter to c(-7,2)
# full effective range of the beta parameter (according to D Johnson)
nested_birds <- mutate(nested_birds,
                fit = purrr::map(data, ~{crawl::crwMLE(mov.model=~1, 
                                                       data=.x, 
                                                       coord=c("lon", "lat"), # movement model = ~1 bc no covariates
                                                       Time.name="time",
                                                       #time.scale='hours', # sometimes need to turn this on, sometimes don't
                                                       method="L-BFGS-B", # there are different optimization methods, default didn't work but this did
                                                       constr=list(lower=c(-Inf,-7), upper=c(Inf,2)),
                                                       attempts=20,
                                                       time.scale = "hours")}
                )
)

nested_birds <- mutate(nested_birds,
                pred = purrr::map(fit, ~{
                  crawl::crwPredict(.x, predTime="24 hours", return.type='flat') %>% # use 24 hours, NOT 1 day (because it rounds to the unit)
                    crawl::crw_as_tibble()
                }
                )
)

unnested_birds <- dplyr::select(nested_birds, ID, pred) %>% unnest(cols=pred)
```

# create momentuHMMData object; would specify covariates if included in the dataset
##  basically the step length and turn angles are now included
## Also create a data stream for difference in latitude (may be necessary for a ruleset: if not, remove)
```{r}
# amwo_hmm <- amwo_spring_males %>%
#   rename(x = lon, y = lat) 
amwo_hmm <- unnested_birds %>%
  rename(x = mu.x, y = mu.y) %>% 
  ungroup()

#remove duplicates by date to deal with predicted locations on the same day as the observed location
amwo_hmm <- amwo_hmm %>% 
  mutate(date = strftime(time, format="%Y-%m-%d"),
         locType = factor(locType, levels = c("o", "p"), ordered = TRUE)) %>% 
  arrange(ID, date, locType) %>% #keep observed locations above predicted locations
  distinct(ID, date, .keep_all = TRUE) %>% 
  mutate(julian_day = yday(ymd(date))) #Redo the julian day calculation

amwo_hmm$lat_diff <- map(1:nrow(amwo_hmm),  function(i){
  if(i == 1){return(NA)} else{#for the first row, return 1
    if(amwo_hmm[i,"ID"] != amwo_hmm[i-1,"ID"]){ #is this the first point for this ID? Return NA
      return(NA)
    } else{
      return(amwo_hmm[i,"y"] - amwo_hmm[i-1,"y"])
    }
  }
}) %>% unlist()

amwo_hmm <- amwo_hmm %>%
  mutate(lat_diff_abs = abs(lat_diff)) %>% 
  dplyr::select(ID, animal_name, year, locType, x, y, time, date, julian_day) %>% 
  as.data.frame()
  
```

Identify loops produced by the crawl and replace them with evenly-spaced points
```{r include = FALSE}
plan(multisession)
nested_birds_2 <- amwo_hmm %>%
  group_by(ID) %>%
  nest()

nested_birds_2$data <- nested_birds_2 %>% 
  pull(data) %>% 
  future_map(.f = function(x){

    x <- x %>% 
      mutate(., rownum = 1:nrow(.))
    
    #Transform to 5070 so I can interpolate points
    x_coords <- x %>%
      st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
      st_transform(5070) %>% 
      st_coordinates() %>% 
      as.data.frame()
    
    x$x <- x_coords$X
    x$y <- x_coords$Y
    
    observed_locs <- x %>%
      filter(locType == "o")
    
    for(i in 1:(nrow(observed_locs)-1)){
      #print(i)
      point_1 <- observed_locs[i,] %>%
        st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
      
      point_2 <- observed_locs[i + 1,] %>%
        st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
      
      point_dist <- st_distance(point_1, point_2,) %>%
        as.numeric(.)
      
      total_dist <- x[c(point_1$rownum, point_1$rownum:point_2$rownum),] %>%
        as.data.frame() %>% 
        prepData(type = "UTM") %>%
        pull(step) %>%
        sum(na.rm = TRUE)
      
      if(total_dist > (10*point_dist)){ #if the total step distance is more than 10 times the distance between observed points, replace with equally spaced between the points
        x_step <- (point_2$x - point_1$x)/(point_2$rownum - point_1$rownum)
        y_step <- (point_2$y - point_1$y)/(point_2$rownum - point_1$rownum)
        for(j in (point_1$rownum+1):(point_2$rownum-1)){
          #paste("Row number:", j) %>%  print()
          loop_index <- j - point_1$rownum
          
          #paste("Initial x:", x$x[j]) %>%  print()
          x$x[j] <- x$x[point_1$rownum] + (x_step*loop_index)
          #paste("Final x:", x$x[j]) %>%  print()
          
          #paste("Initial y:", x$y[j]) %>%  print()
          x$y[j] <- x$y[point_1$rownum] + (y_step*loop_index)
          #paste("Final y:", x$y[j]) %>%  print()
        }
      } 
    }
    #Cleanup
    x$rownum <- NULL
    
    #transform back to 4326
    x_coords <- x %>%
      st_as_sf(coords = c("x", "y"), crs = 5070) %>% 
      st_transform(4326) %>% 
      st_coordinates() %>% 
      as.data.frame()
    
    x$x <- x_coords$X
    x$y <- x_coords$Y
    
    return(x)
  })

amwo_hmm <- nested_birds_2 %>% 
  unnest(cols = c(data))

plan(sequential)
```

Determine the mean distance to the nearest 7 points
```{r}
plan(multisession)

amwo_hmm$mean_dist_7 <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter)
    
    st_distance(x = iter_sf, y = other_locs) %>% 
      as.numeric() %>%
      sort() %>%
      .[2:8] %>% 
      mean(na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```

Determining the amount of time that the bird has spent/will spend within a 10km radius of the point
```{r}
plan(sequential)
amwo_hmm$residence_time <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>% 
      st_transform(5070) %>% 
      st_buffer(10000) %>% #10 km radius
      transmute(intersection = 1)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter) %>% 
      st_transform(5070) %>% 
      transmute(date = ymd(date))
    
    intersected_locs <- other_locs %>% 
      st_join(iter_sf) %>% 
      filter(intersection == 1)
    
    as.numeric(max(intersected_locs$date, na.rm = TRUE) - min(intersected_locs$date), na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```

Determining the log distance from the first point to the current point
```{r}
plan(multisession)

nested_birds_3 <- amwo_hmm %>%
  group_by(ID) %>%
  nest()

nested_birds_3$data <- nested_birds_3 %>% 
  pull(data) %>% 
  future_map(.f = function(int){
    
    int <- int %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
    
    dist_vect <- st_distance(x = int[1,], y = int, by_element = FALSE) %>% #results in meters
      as.numeric() #NOTE: NEEDS sf 1.0-9 to work correctly
    
    # dist_vect <- log(dist_vect + 1.1)
    dist_vect <- if_else(dist_vect < 16100, 0, 1)
    
    int <- int %>% 
      st_drop_geometry() %>% 
      mutate(dist_start = dist_vect)
    
    return(int)
  })

amwo_hmm <- nested_birds_3 %>% 
  unnest(cols = c(data))

plan(sequential)
```

Extract breeding season abundance for each point
```{r}
ebirdst_breeding <- terra::rast(here("ebirdst_abundance", "amewoo_abundance_seasonal_breeding_max_2021.tif"))

amwo_hmm$breeding_abundance <- amwo_hmm %>% 
  st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
  st_transform(st_crs(ebirdst_breeding)) %>% 
  terra::vect() %>% 
  terra::extract(x = ebirdst_breeding, y = .) %>% 
  mutate(breeding = if_else(is.na(breeding), 0, breeding)) %>% 
  pull(breeding) 

amwo_hmm <- amwo_hmm %>% #simplify from abundance to breeding range
  mutate(breeding_abundance = if_else(breeding_abundance > 0, 1, 0)) 
```

```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(log_mean_dist_7 = log(mean_dist_7 + 0.1)) %>% #Adding a small # to deal with 0 distances
  as.data.frame() %>%
  prepData(type = "LL") %>% #, covNames = c("julian_day", "log_mean_dist_7")
  mutate(step = round(step, digits = 4)) %>%   #round down to a tenth of a meter, which is higher than our GPS precision
  mutate(step_500 = if_else(step < 5, 0, 1)) %>% #larger than 5km
  mutate(step_500 = if_else(!is.na(step_500), step_500, 0))
```

#remove early spring movements which throw off the hmm for NJ-2018-08-2019, NJ-2018-13-2019, and NJ-2018-15-2019. Add it back again at the end as a manually-delineated residential movement at the end (or not, as this code only cares about delineating state-shift dates)
```{r}
# early_spring_movement <- amwo_hmm %>%
#   mutate(id_time = paste(ID, as.character(time))) %>%
#   filter(id_time == "VA-2020-52-2020 2020-06-18 21:00:00" | id_time == "VA-2020-52-2020 2020-06-28 14:00:00") %>%
#   mutate(id_time = NULL)

early_spring_movement <- amwo_hmm %>%
  filter((ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32")) |
         (ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-14 00:00:00")) |
         (ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-05 00:00:00")))

amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32"))) %>%
  filter(!(ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-14 00:00:00"))) %>%
  filter(!(ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-05 00:00:00")))

#additionally trimming RI-2020-31; I won't add it back in (not necessary for this workflow). Algorithm catches the tail end of fall migration and pushes it into spring mig too early.
amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "RI-2020-31-2021" & time <= ymd_hms("2021-03-02 18:59:12")))

amwo_hmm <- amwo_hmm %>% #removing ranging movements
  filter(!(ID == "AL-2022-15-2022" & time == ymd_hms("2022-02-28 17:00:00"))) %>% 
  filter(!(ID == "AL-2021-12-2021" & time == ymd_hms("2021-02-25 17:00:00"))) %>%
  filter(!(ID == "NJ-2018-15-2019" & time == ymd_hms("2019-01-14 04:00:00"))) %>% 
  filter(!(ID == "VA-2019-45-2020" & time > ymd_hms("2020-06-22 04:00:00"))) %>% #same thing with midsummer movements
  filter(!(ID == "VA-2021-98-2022" & time > ymd_hms("2022-05-30 15:00:00"))) %>%
  filter(!(ID == "VA-2022-100-2022" & time > ymd_hms("2022-06-19 09:00:00"))) %>% 
  filter(!(ID == "VA-2019-36-2020" & time > ymd_hms("2020-06-19 01:59:28"))) %>% 
  filter(!(ID == "AL-2021-10-2021" & time == ymd_hms("2021-05-21 03:58:56"))) %>%
  filter(!(ID == "AL-2021-10-2021" & time == ymd_hms("2021-05-21 17:00:00"))) %>% 
  filter(!(ID == "AL-2021-12-2021" & time == ymd_hms("2021-02-26 05:02:56")))
```

remove birds with no individual step lengths >30.2km (20 miles). In practice this pulls birds that never initiate a substantial migratory movement but doesn't penalize birds that DO migrate, as they always make at least one substantial movement.
Also recording which individuals are removed
```{r}
amwo_hmm$min.step <- ifelse(amwo_hmm$step > 30.2, 1, 0)
individuals_removed_for_no_migratory_steps <- unique(amwo_hmm$ID [amwo_hmm$min.step == 1])
amwo_hmm <- amwo_hmm[(amwo_hmm$ID %in% amwo_hmm$ID [amwo_hmm$min.step == 1]) , ]
amwo_hmm$min.step <- NULL
```

Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>%
  mutate(known = ifelse(ranks == "1", 1, NA)) %>%
  mutate(known = ifelse(ID == "VA-2019-22-2019" & ranks < 6, 1, known)) %>% #accidentally slips into 3 too early
  mutate(known = ifelse(ID == "VA-2021-91-2021" & ranks %in% c(16, 17, 18), 2, known)) %>% #crw stops the bird from slipping into mig
  mutate(known = ifelse(ID == "VA-2021-92-2021" & ranks %in% c(6, 7, 8), 2, known)) %>% #crw stops the bird from slipping into mig
  pull(known)
```

##### trying 5-state model

Label states and create distributions for movements
```{r}
stateNames <- c("pre", "migration", "stopover", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern", log_mean_dist_7 = "norm", residence_time = "norm") #,  
```

fix step length parameters and state transitions
```{r}
fixPar <- list(beta=matrix(c(NA, -1000,	-1000,	-1000,	NA,	NA,	-1000,	NA,	-1000,	-1000,	-1000,	-1000), nrow = 1, byrow = TRUE),
               step_500 = c(NA, 0.999999999, NA, NA)) 
```

These serve as the starting parameters for the HMM to optimize.
```{r}
Par0_m1 <- list(step=c(0.260832696, 9.429288e+01, 0.323209095, 0.1581120, #mean in km
                       0.434046082, 9.829083e+01, 0.565636024 , 0.2682378, # SD in km
                       0.002864053, 1.549953e-09, 0.008935152, 0.0101826), #zeromass ie how many zeroes expected in the distribution
                angle=c(0.001212793, -0.004443658, -0.004534878, 0.0003999368, #mean
                        0.882238488, 0.911903062, 0.405040026, 0.7535390314),
                y = c(35.142723, 40.642156, 41.012048,  44.801910,
                      2.567658, 4.407258, 3.666311, 3.010217),
                julian_day = c(41.63823, 86.00518, 88.73997, 141.08671, #mean
                               20.60346, 26.04991, 25.50664, 23.33606),#concentration
                log_mean_dist_7 = c(3.601858, 9.920471, 4.539150, 3.114167, #mean
                                    1.610840, 2.643817, 2.938573, 1.637662), #sd
                residence_time = c(49.87944, 7.546966, 26.48728, 66.52459, #mean
                                   21.66159, 16.575491, 20.09901, 22.88829), #sd
                dist_start = c(0.01667985, 0.9264421, 0.9762556, 0.999999), #prob
                step_500 = c(0.002299856, 0.99999, 7.443581e-09, 0.00255622), #prob
                breeding_abundance = c(0.1159913, 0.4453295, 0.5308599, 0.8146863)) #prob
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=4, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               #userBounds = userBounds,
               #workBounds = workBounds,
               #DM = DM,
               knownStates = knownStates,
               #formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1 | i == 1){
      return(1) #for the first and second rows, return 1
    } else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
      return(1)
    } else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
      return(.x[i,"step_state"])
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1 & .x[i,"ID"] == .x[i-2,"ID"]){ #is the current step state mig and the previous step pre-mig, and is this not step 1 or 2? Return pre-mig
      return(1)
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
      return(3)
    } else{ #in all other circumstances, return the current step state
      return(.x[i,"step_state"])
    }

  }) %>% unlist()
  
  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r}
start_time <- Sys.time()
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states 
end_time <- Sys.time()
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm_final <- results_initial$results

results_initial$model #probabilities of transition

print(start_time)
print(end_time)
```


Ruleset: If the total step distance between the start of 4 and the most recent 3 is less than 5 km, then everything from the top of the most recent 3 down is 4
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, ...){
    iter_df <- iter_df %>%
      mutate(., row_num = 1:nrow(.))

    if(any(iter_df$point_state == 3) & any(iter_df$point_state == 4 |iter_df$point_state == 5)){
      first_4_row <- iter_df %>%
        filter(point_state == 4 | point_state == 5) %>%
        pull(row_num) %>%
        min()

      last_3_row <- iter_df %>%
        filter(point_state == 3) %>%
        pull(row_num) %>%
        max()

      total_dist_moved <- iter_df[last_3_row:(first_4_row-1), "step"] %>%
        sum()

      if(total_dist_moved < 5){
        start_of_last_stopover <- iter_df[1:(last_3_row-1),] %>%
          filter(point_state == 2) %>%
          pull(row_num) %>%
          max(.) + 1

        iter_df[start_of_last_stopover:nrow(iter_df), "point_state"] <- 4
      }
    }
    return(iter_df)
  }) %>%
  ungroup() %>%
  mutate(row_num = NULL)
```

Ruleset: If the total step distance between the end of 1 and the 1st 3 is less than 5 km, then everything until the last 3 in that sequence is 1
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  group_by(ID) %>%
  group_modify(function(iter_df, id){
    iter_df <- iter_df %>%
      mutate(., row_num = 1:nrow(.))

    if(any(iter_df$point_state == 3) & any(iter_df$point_state == 2)){
      first_3_row <- iter_df %>%
        filter(point_state == 3) %>%
        pull(row_num) %>%
        min()

      last_1_row <- iter_df %>%
        filter(point_state == 1) %>%
        pull(row_num) %>%
        max()

      total_dist_moved <- iter_df[last_1_row:(first_3_row-1), "step"] %>%
        sum()

      if(total_dist_moved < 5){
        end_of_first_stopover <- iter_df[first_3_row:nrow(iter_df),] %>%
          filter(point_state == 2) %>%
          pull(row_num) %>%
          min(.) - 1

        iter_df[1:end_of_first_stopover, "point_state"] <- 1
      }
    }
    return(iter_df)
  }) %>%
  ungroup() %>%
  mutate(row_num = NULL)
```

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
Gonna try not doing this, as all I really care about are the migratory initiation dates
```{r}
# early_spring_movement %>%
#   mutate(step_state = 1, point_state = 1) ->
#   early_spring_movement
# 
# amwo_hmm %>%
#   rbind(early_spring_movement) ->
#   amwo_hmm
```

Correct step state based on the new point states
If:
- This point state is migratory
or
- there is a change in point state between this and the next i
then the state is migratory. otherwise, it is equal to the current point state

if we're on the last row for the individual, skip this determination and return NA
Not currently implemented
```{r}
# amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
#   #print(ind)
#   amwo_ind <- amwo_hmm_final %>%
#     filter(ID == ind)
#   
#   ind_vect <- c()
#   
#   for(i in 1:(nrow(amwo_ind)-1)){
#     #print(i)
#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#   
#   ind_vect <- append(ind_vect, NA)
#   
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
```

Last bit: remove all of the false migrations
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  filter(ID != "NJ-2019-28-2020",
         ID != "NS-2019-02-2020",
         ID != "RI-2020-42-2021",
         ID != "RI-2021-47-2022", #midatlantic transitory movement
         ID != "RI-2021-52-2022", #midatlantic transitory movement
         ID != "NY-2022-40-2022") #post-nesting dispersal movement
```

```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here::here("classifier_spring", "spring_female_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_spring", "spring_female_4_state_parameters.rds"))
```

