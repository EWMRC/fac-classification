---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

This is a streamlined version of what Erik originally wrote in momentuHMM_amwo_Spring_Male2. Uses HMMs to determine if birds settle after migration, and then uses a ruleset to define when each state starts and stops

Last bit: remove all of the false migrations

```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Extract all locations from 2019, 2020, and 2021 from Jan 5th through June 30th
```{r include=FALSE}
login <- movebankLogin(username = "LA_Berigan", password="33szcNUtv4iyPGU")
amwo_2018 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20180105000000000", timestamp_end = "20180630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2019 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20190105000000000", timestamp_end = "20190630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2020 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20200105000000000", timestamp_end = "20200630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2021 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20210105000000000", timestamp_end = "20210630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2022 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20220105000000000", timestamp_end = "20220630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
```

Formatting and cleaning, including creating time columns and simplifying to one location per day
```{r}
amwo_spring <- as.data.frame(rbind(amwo_2018, amwo_2019, amwo_2020, amwo_2021, amwo_2022))

amwo_spring <- amwo_spring %>%
  transmute(ID = local_identifier,
            #time = as.POSIXct(round(force_tzs(timestamp, tzone = "GMT", tzone_out = "EST"), "hour")), #time rounded in EST
            time = timestamp,
            lon = location_long,
            lat = location_lat,
            tagtype = comments,
            sex = sex,
            age = taxon_detail,
            altitude = height_above_msl)

amwo_spring <- amwo_spring %>%
  mutate(t = strftime(time, format="%H:%M"),
         date = strftime(time, format="%Y-%m-%d")) #%>%
  #distinct(date, ID, .keep_all = TRUE) # remove multiple locations on same day, mainly retaining only 1 of 3 locations 1st day after marking
```

Converting all age classes to juvenile and adult
```{r}
amwo_spring <- amwo_spring %>%
  mutate(age = recode_factor(age,
                             "Second Year" = "juv",
                             "Hatch Year" = "juv",
                             "After Hatch Year" = "ad",
                             "After Second Year" = "ad",
                             "Third Year" = "ad",
                             "After Third Year" = "ad"))
```

Extracting tag type, schedule, state marked, and year
```{r}
amwo_spring <- amwo_spring %>%
  separate(tagtype, c("tagtype", "second", "schedule"), sep = " ") %>% 
  dplyr::select(-second) %>%
  mutate(ID2 = ID) %>%
  separate(ID2, c("m.state", "m.year", "third"), sep = "-") %>% 
  dplyr::select(-third)
```

Filtering to just females and individuals with unknown sex
```{r}
amwo_spring_males <- amwo_spring %>%
  filter(sex == "f" | sex == "")
```

Account for potential duplicate years by adding a year to the end of the id
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(year = strftime(time, format="%Y")) %>%
  mutate(animal_name = ID,
         ID = paste(ID, year, sep="-"))
```

Add a julian day column (new data stream)
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(julian_day = yday(ymd(date)))
```

Remove individuals with fewer than 3 locations, recording which ones were removed
```{r}
individuals_removed_for_too_few_locations <- amwo_spring_males %>%
  group_by(ID) %>%
  tally() %>%
  filter(n < 3) %>%
  pull(ID)

birds_to_keep <- amwo_spring_males %>%
  group_by(ID) %>%
  tally() %>%
  filter(n > 2) %>%
  pull(ID)

amwo_spring_males <- amwo_spring_males %>%
  filter(ID %in% birds_to_keep)
```

Flag individuals tagged after February 15th on the year of observation so that I can mark their initial stationary state as uncertain
```{r include = FALSE}
# Comment this out if running repeatedly; otherwise it will just slow down the code
# googledrive::as_id("https://drive.google.com/file/d/19JA5OztH3hS4MPfVnH5zswDxSSLcWxL3/view?usp=sharing") %>%
#         googledrive::drive_download(path = here("capture_sheet.xlsx"), overwrite = TRUE)

capture_dates <- readxl::read_excel(here("capture_sheet.xlsx"), col_types = c("text", "text", "date", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text")) %>%
        mutate(`Argos_ID` = as.character(`Argos_ID`)) %>%
  transmute(animal_name = `Movebank_ID`,
            capture_date = Date)

individuals_tagged_too_late <- amwo_spring_males %>%
  left_join(capture_dates) %>%
  filter((year == year(capture_date) & mdy(paste0("2/15/", year)) < capture_date)) %>% #remove locations when the bird was caught after Oct 15 in the year of concern
  dplyr::select(ID, animal_name, year) %>%
  distinct()
```

Flag individuals which died before May 15th on the year of observation so that I can mark their final stationary state as uncertain. Don't worry about the 2020 thing, it's just a standardized year.

### This will bias any survival analyses done with these designations ###
```{r}
individuals_died_too_early <- amwo_spring_males %>%
  group_by(ID) %>%
  summarise(max_time = max(time)) %>%
  mutate(max_date = mdy(paste0(month(max_time), "/", day(max_time), "/2020"))) %>%
  filter(max_date < mdy("5/15/2020")) %>%
  pull(ID)
```


Crawl code goes here
```{r include=FALSE}
# Group tracks by id (for crawl model because it likes tidyverse structure)
nested_birds <- group_by(amwo_spring_males, ID) %>% 
  nest() 

# Movement model (no covariates = ~1)
# The constraints are based on the godwit example
# Fit model to each bird. Constrain velocity autoregression parameter to c(-7,2)
# full effective range of the beta parameter (according to D Johnson)
nested_birds <- mutate(nested_birds,
                fit = purrr::map(data, ~{crawl::crwMLE(mov.model=~1, 
                                                       data=.x, 
                                                       coord=c("lon", "lat"), # movement model = ~1 bc no covariates
                                                       Time.name="time",
                                                       #time.scale='hours', # sometimes need to turn this on, sometimes don't
                                                       method="L-BFGS-B", # there are different optimization methods, default didn't work but this did
                                                       constr=list(lower=c(-Inf,-7), upper=c(Inf,2)),
                                                       attempts=20,
                                                       time.scale = "hours")}
                )
)

nested_birds <- mutate(nested_birds,
                pred = purrr::map(fit, ~{
                  crawl::crwPredict(.x, predTime="24 hours", return.type='flat') %>% # use 24 hours, NOT 1 day (because it rounds to the unit)
                    crawl::crw_as_tibble()
                }
                )
)

unnested_birds <- dplyr::select(nested_birds, ID, pred) %>% unnest(cols=pred)
```

# create momentuHMMData object; would specify covariates if included in the dataset
##  basically the step length and turn angles are now included
## Also create a data stream for difference in latitude (may be necessary for a ruleset: if not, remove)
```{r}
# amwo_hmm <- amwo_spring_males %>%
#   rename(x = lon, y = lat) 

amwo_hmm <- unnested_birds %>%
  rename(x = mu.x, y = mu.y) %>% 
  ungroup()

#remove duplicates by date to deal with predicted locations on the same day as the observed location
amwo_hmm <- amwo_hmm %>% 
  mutate(date = strftime(time, format="%Y-%m-%d")) %>% 
  arrange(ID, date, locType) %>% #keep observed locations above predicted locations
  distinct(date, ID, .keep_all = TRUE) %>% 
  mutate(julian_day = yday(ymd(date))) #Redo the julian day calculation

amwo_hmm$lat_diff <- map(1:nrow(amwo_hmm),  function(i){
  if(i == 1){return(NA)} else{#for the first row, return 1
    if(amwo_hmm[i,"ID"] != amwo_hmm[i-1,"ID"]){ #is this the first point for this ID? Return NA
      return(NA)
    } else{
      return(amwo_hmm[i,"y"] - amwo_hmm[i-1,"y"])
    }
  }
}) %>% unlist()

amwo_hmm <- amwo_hmm %>%
  mutate(lat_diff_abs = abs(lat_diff)) %>% 
  dplyr::select(ID, animal_name, year, locType, x, y, time, date, julian_day) %>% 
  as.data.frame()
  
```

Identify loops produced by the crawl and replace them with evenly-spaced points
```{r include = FALSE}
plan(multisession)
nested_birds_2 <- amwo_hmm %>%
  group_by(ID) %>%
  nest()

nested_birds_2$data <- nested_birds_2 %>% 
  pull(data) %>% 
  future_map(.f = function(x){

    x <- x %>% 
      mutate(., rownum = 1:nrow(.))
    
    #Transform to 5070 so I can interpolate points
    x_coords <- x %>%
      st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
      st_transform(5070) %>% 
      st_coordinates() %>% 
      as.data.frame()
    
    x$x <- x_coords$X
    x$y <- x_coords$Y
    
    observed_locs <- x %>%
      filter(locType == "o")
    
    for(i in 1:(nrow(observed_locs)-1)){
      #print(i)
      point_1 <- observed_locs[i,] %>%
        st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
      
      point_2 <- observed_locs[i + 1,] %>%
        st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
      
      point_dist <- st_distance(point_1, point_2,) %>%
        as.numeric(.)
      
      total_dist <- x[c(point_1$rownum, point_1$rownum:point_2$rownum),] %>%
        as.data.frame() %>% 
        prepData(type = "UTM") %>%
        pull(step) %>%
        sum(na.rm = TRUE)
      
      if(total_dist > (10*point_dist)){ #if the total step distance is more than 10 times the distance between observed points, replace with equally spaced between the points
        x_step <- (point_2$x - point_1$x)/(point_2$rownum - point_1$rownum)
        y_step <- (point_2$y - point_1$y)/(point_2$rownum - point_1$rownum)
        for(j in (point_1$rownum+1):(point_2$rownum-1)){
          #paste("Row number:", j) %>%  print()
          loop_index <- j - point_1$rownum
          
          #paste("Initial x:", x$x[j]) %>%  print()
          x$x[j] <- x$x[point_1$rownum] + (x_step*loop_index)
          #paste("Final x:", x$x[j]) %>%  print()
          
          #paste("Initial y:", x$y[j]) %>%  print()
          x$y[j] <- x$y[point_1$rownum] + (y_step*loop_index)
          #paste("Final y:", x$y[j]) %>%  print()
        }
      } 
    }
    #Cleanup
    x$rownum <- NULL
    
    #transform back to 4326
    x_coords <- x %>%
      st_as_sf(coords = c("x", "y"), crs = 5070) %>% 
      st_transform(4326) %>% 
      st_coordinates() %>% 
      as.data.frame()
    
    x$x <- x_coords$X
    x$y <- x_coords$Y
    
    return(x)
  })

amwo_hmm <- nested_birds_2 %>% 
  unnest(cols = c(data))

plan(sequential)
```

Determine the mean distance to the nearest 7 points
```{r}
plan(multisession)

amwo_hmm$mean_dist_7 <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter)
    
    st_distance(x = iter_sf, y = other_locs) %>% 
      as.numeric() %>%
      sort() %>%
      .[2:8] %>% 
      mean(na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```

Determining the amount of time that the bird has spent/will spend within a 10km radius of the point
```{r}
plan(multisession)
amwo_hmm$residence_time <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>% 
      st_transform(5070) %>% 
      st_buffer(10000) %>% #10 km radius
      transmute(intersection = 1)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter) %>% 
      st_transform(5070) %>% 
      transmute(date = ymd(date))
    
    intersected_locs <- other_locs %>% 
      st_join(iter_sf) %>% 
      filter(intersection == 1)
    
    as.numeric(max(intersected_locs$date, na.rm = TRUE) - min(intersected_locs$date), na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```

```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(log_mean_dist_7 = log(mean_dist_7 + 0.1)) %>% #Adding a small # to deal with 0 distances
  as.data.frame() %>% 
  prepData(type = "LL") %>% #, covNames = c("julian_day", "log_mean_dist_7")
  mutate(step = round(step, digits = 4))
```

#remove early spring movements which throw off the hmm for NJ-2018-08-2019, NJ-2018-13-2019, and NJ-2018-15-2019. Add it back again at the end as a manually-delineated residential movement at the end (or not, as this code only cares about delineating state-shift dates)
```{r}
# early_spring_movement <- amwo_hmm %>%
#   mutate(id_time = paste(ID, as.character(time))) %>%
#   filter(id_time == "VA-2020-52-2020 2020-06-18 21:00:00" | id_time == "VA-2020-52-2020 2020-06-28 14:00:00") %>%
#   mutate(id_time = NULL)

early_spring_movement <- amwo_hmm %>%
  filter((ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32")) |
         (ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-14 00:00:00")) |
         (ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-05 00:00:00")))

amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32"))) %>%
  filter(!(ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-14 00:00:00"))) %>%
  filter(!(ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-05 00:00:00")))

#additionally trimming RI-2020-31; I won't add it back in (not necessary for this workflow). Algorithm catches the tail end of fall migration and pushes it into spring mig too early.
amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "RI-2020-31-2021" & time <= ymd_hms("2021-03-02 18:59:12")))

```

remove birds with no individual step lengths >30.2km (20 miles). In practice this pulls birds that never initiate a substantial migratory movement but doesn't penalize birds that DO migrate, as they always make at least one substantial movement.
Also recording which individuals are removed
```{r}
amwo_hmm$min.step <- ifelse(amwo_hmm$step > 30.2, 1, 0)
individuals_removed_for_no_migratory_steps <- unique(amwo_hmm$ID [amwo_hmm$min.step == 1])
amwo_hmm <- amwo_hmm[(amwo_hmm$ID %in% amwo_hmm$ID [amwo_hmm$min.step == 1]) , ]
amwo_hmm$min.step <- NULL
```


Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>%
  mutate(known = ifelse(ranks == "1", 1, NA)) %>%
  pull(known)
```

##### 4-state model

Label states and create distributions for movements
```{r}
stateNames <- c("pre","migration", "stopover","post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", log_mean_dist_7 = "norm", residence_time = "norm")# , pts_10mi_log = "norm", lat_diff_abs = "gamma"
```

fix step length parameters and state transitions
```{r}
fixPar <- list(beta=matrix(c(NA, -1000, -1000, # pre-migration to transitions, can't go pre- to post
                     -1000, NA, NA,  #once entered migration can't go back to pre
                     -1000, NA, -1000, #Once entered stopover, can only go back to migration
                     -1000, -1000, -1000), nrow = 1, byrow = TRUE)) #once entered post-migration, can't leave
```

These serve as the starting parameters for the HMM to optimize.
```{r}
#Informed priors
Par0_m1 <- list(step=c(0.36553000, 57.96369562, 0.36553000, 0.20293436, #mean in km
                       0.48229603, 140.73763264, 0.48229603, 0.26933843, # SD in km
                       0.01593086, 0.02918066, 0.01593086, 0.08298248), #zeromass ie how many zeroes expected in the distribution
                angle=c(-3.1360643, 3.0924885, 3.1388950, -3.1388950, #mean
                        0.5024427, 0.2242694, 0.4235424, 0.4235424), #concentration
                y = c(34.32931, 36.79636, 36.79636, 41.58981,
                      2.398324,4.035114, 4.035114, 4.433215),
                julian_day = c(20, 50, 80, 140, #mean 100
                        10, 10, 30 ,30), 
                log_mean_dist_7 = c(log(100), log(5000), log(100), log(100), #mean
                                log(50), log(20), log(50), log(50)),
                residence_time = c(40.2, 7.39, 55.9, 70.6, #mean
                                   21.6, 16.4, 32.0, 21.3)) #sd
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=4, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               #knownStates = knownStates,
               #formula = ~julian_day + log_mean_dist_7, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points

  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r}
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states 

#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm_final <- results_initial$results

results_initial$model #probabilities of transition
```


The ruleset fails to designate a summering location for VA-2019-46 and SC-2019-03 due to late settlement (not enough points in the area before 6/30). If the window was longer it would correct this, but throw off other observations due to post-breeding dispersal movements. I'll manually force VA-2019-46 and SC-2019-03's final locations into state 3 instead.
## NOTE: CRW may change this, so i'm commenting out for now. Will put them back in on a case-by-case basis
```{r}
# amwo_hmm <- amwo_hmm %>%
#   mutate(step_state = ifelse(animal_name == "VA-2019-46" & date == "2020-06-28", 3, step_state),
#          point_state = ifelse(animal_name == "VA-2019-46" & date == "2020-06-28", 3, point_state)) %>%
#   mutate(step_state = ifelse(animal_name == "SC-2019-03" & date == "2019-06-28", 3, step_state),
#          point_state = ifelse(animal_name == "SC-2019-03" & date == "2019-06-28", 3, point_state))
```

Ruleset: Pre-migration is all points up until the bird departs > 16.1km from its initial location for the final time
```{r}
amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
  first_loc <- amwo_hmm_final %>%
    filter(ID == ind) %>%
    head(n = 1) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)

  amwo_ind <- amwo_hmm_final %>%
    filter(ID == ind) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
    mutate(condition_distance_km_pre = as.numeric(st_distance(geometry, first_loc))/1000) %>%
    st_drop_geometry() %>%
    mutate(within_dist_pre = condition_distance_km_pre < 16.1) #10
  
  amwo_ind <- amwo_ind %>%
    mutate(row_num = 1:nrow(amwo_ind))
  
  highest_premig_row <- amwo_ind %>%
    filter(within_dist_pre == 1) %>%
    pull(row_num) %>%
    max()
  
  if(highest_premig_row < -1000){
    cat(crayon::magenta("no points within 16.1 kilometers of the centroid"))
  }
  
  amwo_ind <- amwo_ind %>% 
    mutate(point_state = if_else(row_num <= highest_premig_row, 1 , point_state)) %>% #point_state_premig_corrected
    mutate(condition_distance_km_pre = NULL,
           within_dist_pre = NULL,
           row_num = NULL)
}) %>%
  exec("bind_rows", .)

```

Ruleset: Post-migration is all points up until the bird comes within 8km of its final location for the first time, assuming that its final location is in state 3
```{r}
amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
  last_loc <- amwo_hmm_final %>%
    filter(ID == ind) %>%
    tail(n = 1) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
  
  amwo_ind <- amwo_hmm_final %>%
    filter(ID == ind) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
    mutate(condition_distance_km_post = as.numeric(st_distance(geometry, last_loc))/1000) %>%
    st_drop_geometry() %>%
    mutate(within_dist_post = condition_distance_km_post < 8) #16.1
  
  amwo_ind <- amwo_ind %>%
    mutate(row_num = 1:nrow(amwo_ind))
  
  lowest_postmig_row <- amwo_ind %>%
    filter(within_dist_post == 1) %>%
    pull(row_num) %>%
    min()
  
  if(lowest_postmig_row< -1000){
    cat(crayon::magenta("no points within 8 kilometers of the last point"))
  }
  
  if(last_loc$point_state == 4){
    amwo_ind <- amwo_ind %>% 
      mutate(point_state = if_else(row_num >= lowest_postmig_row, 4, point_state)) %>% 
      mutate(within_dist_post = NULL, 
        condition_distance_km_post = NULL,
        row_num = NULL)
  } else {
    amwo_ind <- amwo_ind %>% 
      mutate(within_dist_post = NULL, 
        condition_distance_km_post = NULL,
        row_num = NULL)
  }

  return(amwo_ind)
}) %>%
  exec("bind_rows", .)
```

#
#
Ruleset to do:
If a bird transitions from 3 to 4, include all 3 locations as 4 locations
#
#

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
Gonna try not doing this, as all I really care about are the migratory initiation dates
```{r}
# early_spring_movement %>%
#   mutate(step_state = 1, point_state = 1) ->
#   early_spring_movement
# 
# amwo_hmm %>%
#   rbind(early_spring_movement) ->
#   amwo_hmm
```

Correct step state based on the new point states
If:
- This point state is migratory
or
- there is a change in point state between this and the next i
then the state is migratory. otherwise, it is equal to the current point state

if we're on the last row for the individual, skip this determination and return NA
Not currently implemented
```{r}
# amwo_hmm_final <- map(unique(amwo_hmm_final$ID), function(ind){
#   #print(ind)
#   amwo_ind <- amwo_hmm_final %>%
#     filter(ID == ind)
#   
#   ind_vect <- c()
#   
#   for(i in 1:(nrow(amwo_ind)-1)){
#     #print(i)
#     if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
#       ind_vect <- append(ind_vect, 2)
#     } else {
#       ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
#     }
#   }
#   
#   ind_vect <- append(ind_vect, NA)
#   
#   amwo_ind$step_state <- ind_vect
#   return(amwo_ind)
# }) %>%
#   exec("bind_rows", .)
```

Last bit: remove all of the false migrations
```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  filter(ID != "NJ-2019-28-2020",
         ID != "NS-2019-02-2020",
         ID != "RI-2020-42-2021",
         ID != "RI-2021-47-2022", #midatlantic transitory movement
         ID != "RI-2021-52-2022", #midatlantic transitory movement
         ID != "NY-2022-40-2022") #post-nesting dispersal movement
```

```{r}
amwo_hmm_final <- amwo_hmm_final %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm_final, file = here::here("classifier_spring", "spring_female_4_state_model.rds"))
saveRDS(results_initial$model, file = here("classifier_spring", "spring_female_4_state_parameters.rds"))
```

