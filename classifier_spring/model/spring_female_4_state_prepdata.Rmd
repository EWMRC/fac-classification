---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Extract all locations from 2019, 2020, and 2021 from Jan 5th through June 30th
```{r include=FALSE}
login <- movebankLogin(username = "LA_Berigan", password="33szcNUtv4iyPGU")
amwo_2018 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20180105000000000", timestamp_end = "20180630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2019 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20190105000000000", timestamp_end = "20190630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2020 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20200105000000000", timestamp_end = "20200630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2021 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20210105000000000", timestamp_end = "20210630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2022 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20220105000000000", timestamp_end = "20220630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
```

Formatting and cleaning, including creating time columns and simplifying to one location per day
```{r}
amwo_spring <- as.data.frame(rbind(amwo_2018, amwo_2019, amwo_2020, amwo_2021, amwo_2022))

amwo_spring <- amwo_spring %>%
  transmute(ID = local_identifier,
            #time = as.POSIXct(round(force_tzs(timestamp, tzone = "GMT", tzone_out = "EST"), "hour")), #time rounded in EST
            time = timestamp,
            lon = location_long,
            lat = location_lat,
            tagtype = comments,
            sex = sex,
            age = taxon_detail,
            altitude = height_above_msl)

amwo_spring <- amwo_spring %>%
  mutate(t = strftime(time, format="%H:%M"),
         date = strftime(time, format="%Y-%m-%d")) #%>%
  #distinct(date, ID, .keep_all = TRUE) # remove multiple locations on same day, mainly retaining only 1 of 3 locations 1st day after marking
```

Converting all age classes to juvenile and adult
```{r}
amwo_spring <- amwo_spring %>%
  mutate(age = recode_factor(age,
                             "Second Year" = "juv",
                             "Hatch Year" = "juv",
                             "After Hatch Year" = "ad",
                             "After Second Year" = "ad",
                             "Third Year" = "ad",
                             "After Third Year" = "ad"))
```

Extracting tag type, schedule, state marked, and year
```{r}
amwo_spring <- amwo_spring %>%
  separate(tagtype, c("tagtype", "second", "schedule"), sep = " ") %>% 
  dplyr::select(-second) %>%
  mutate(ID2 = ID) %>%
  separate(ID2, c("m.state", "m.year", "third"), sep = "-") %>% 
  dplyr::select(-third)
```

Filtering to just females and individuals with unknown sex
```{r}
amwo_spring_males <- amwo_spring %>%
  filter(sex == "f" | sex == "")
```

Account for potential duplicate years by adding a year to the end of the id
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(year = strftime(time, format="%Y")) %>%
  mutate(animal_name = ID,
         ID = paste(ID, year, sep="-"))
```

Add a julian day column (new data stream)
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(julian_day = yday(ymd(date)))
```

Remove individuals with fewer than 3 locations, recording which ones were removed
```{r}
individuals_removed_for_too_few_locations <- amwo_spring_males %>%
  distinct(ID, date, .keep_all = TRUE) %>% 
  group_by(ID) %>%
  tally() %>%
  filter(n < 3) %>%
  pull(ID)

birds_to_keep <- amwo_spring_males %>%
  distinct(ID, date, .keep_all = TRUE) %>% 
  group_by(ID) %>%
  tally() %>%
  filter(n > 2) %>%
  pull(ID)

amwo_spring_males <- amwo_spring_males %>%
  filter(ID %in% birds_to_keep)
```

Flag individuals tagged after February 15th on the year of observation so that I can mark their initial stationary state as uncertain
```{r include = FALSE}
# Comment this out if running repeatedly; otherwise it will just slow down the code
# googledrive::as_id("https://drive.google.com/file/d/19JA5OztH3hS4MPfVnH5zswDxSSLcWxL3/view?usp=sharing") %>%
#         googledrive::drive_download(path = here("capture_sheet.xlsx"), overwrite = TRUE)

capture_dates <- readxl::read_excel(here("capture_sheet.xlsx"), col_types = c("text", "text", "date", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text")) %>%
        mutate(`Argos_ID` = as.character(`Argos_ID`)) %>%
  transmute(animal_name = `Movebank_ID`,
            capture_date = Date)

individuals_tagged_too_late <- amwo_spring_males %>%
  left_join(capture_dates) %>%
  filter((year == year(capture_date) & mdy(paste0("2/15/", year)) < capture_date)) %>% #remove locations when the bird was caught after Oct 15 in the year of concern
  dplyr::select(ID, animal_name, year) %>%
  distinct()
```

Flag individuals which died before May 15th on the year of observation so that I can mark their final stationary state as uncertain. Don't worry about the 2020 thing, it's just a standardized year.

### This will bias any survival analyses done with these designations ###
```{r}
individuals_died_too_early <- amwo_spring_males %>%
  group_by(ID) %>%
  summarise(max_time = max(time)) %>%
  mutate(max_date = mdy(paste0(month(max_time), "/", day(max_time), "/2020"))) %>%
  filter(max_date < mdy("6/15/2020")) %>%
  pull(ID)
```

Crawl code goes here
First parameter is sigma, second is beta (autocorrelation) rnorm(200,-4,2)
```{r include=FALSE}
# Group tracks by id (for crawl model because it likes tidyverse structure)
nested_birds <- group_by(amwo_spring_males, ID) %>% 
  nest() 

# Movement model (no covariates = ~1)
# The constraints are based on the godwit example
# Fit model to each bird. Constrain velocity autoregression parameter to c(-7,2)
# full effective range of the beta parameter (according to D Johnson)
nested_birds <- mutate(nested_birds,
                fit = purrr::map(data, ~{crawl::crwMLE(mov.model=~1, 
                                                       data=.x, 
                                                       coord=c("lon", "lat"), # movement model = ~1 bc no covariates
                                                       Time.name="time",
                                                       #time.scale='hours', # sometimes need to turn this on, sometimes don't
                                                       method="L-BFGS-B", # there are different optimization methods, default didn't work but this did
                                                       constr=list(lower=c(-Inf,-7), upper=c(Inf,2)),
                                                       attempts=20,
                                                       time.scale = "hours")}
                )
)

nested_birds <- mutate(nested_birds,
                pred = purrr::map(fit, ~{
                  crawl::crwPredict(.x, predTime="24 hours", return.type='flat') %>% # use 24 hours, NOT 1 day (because it rounds to the unit)
                    crawl::crw_as_tibble()
                }
                )
)

unnested_birds <- dplyr::select(nested_birds, ID, pred) %>% unnest(cols=pred)
```

# create momentuHMMData object; would specify covariates if included in the dataset
```{r}
# amwo_hmm <- amwo_spring_males %>%
#   rename(x = lon, y = lat) 
amwo_hmm <- unnested_birds %>%
  rename(x = mu.x, y = mu.y) %>% 
  ungroup()

#remove duplicates by date to deal with predicted locations on the same day as the observed location
amwo_hmm <- amwo_hmm %>% 
  mutate(date = strftime(time, format="%Y-%m-%d"),
         locType = factor(locType, levels = c("o", "p"), ordered = TRUE)) %>% 
  arrange(ID, date, locType) %>% #keep observed locations above predicted locations
  distinct(ID, date, .keep_all = TRUE) %>% 
  mutate(julian_day = yday(ymd(date))) #Redo the julian day calculation

amwo_hmm$lat_diff <- map(1:nrow(amwo_hmm),  function(i){
  if(i == 1){return(NA)} else{#for the first row, return 1
    if(amwo_hmm[i,"ID"] != amwo_hmm[i-1,"ID"]){ #is this the first point for this ID? Return NA
      return(NA)
    } else{
      return(amwo_hmm[i,"y"] - amwo_hmm[i-1,"y"])
    }
  }
}) %>% unlist()

amwo_hmm <- amwo_hmm %>%
  mutate(lat_diff_abs = abs(lat_diff)) %>% 
  dplyr::select(ID, animal_name, year, locType, x, y, time, date, julian_day) %>% 
  as.data.frame()
  
```

Identify loops produced by the crawl and replace them with evenly-spaced points
```{r include = FALSE}
plan(multisession)
nested_birds_2 <- amwo_hmm %>%
  group_by(ID) %>%
  nest()

nested_birds_2$data <- nested_birds_2 %>% 
  pull(data) %>% 
  future_map(.f = function(x){

    x <- x %>% 
      mutate(., rownum = 1:nrow(.))
    
    #Transform to 5070 so I can interpolate points
    x_coords <- x %>%
      st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
      st_transform(5070) %>% 
      st_coordinates() %>% 
      as.data.frame()
    
    x$x <- x_coords$X
    x$y <- x_coords$Y
    
    observed_locs <- x %>%
      filter(locType == "o")
    
    for(i in 1:(nrow(observed_locs)-1)){
      #print(i)
      point_1 <- observed_locs[i,] %>%
        st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
      
      point_2 <- observed_locs[i + 1,] %>%
        st_as_sf(coords = c("x", "y"), crs = 5070, remove = FALSE)
      
      point_dist <- st_distance(point_1, point_2,) %>%
        as.numeric(.)
      
      total_dist <- x[c(point_1$rownum, point_1$rownum:point_2$rownum),] %>%
        as.data.frame() %>% 
        prepData(type = "UTM") %>%
        pull(step) %>%
        sum(na.rm = TRUE)
      
      if(total_dist > (10*point_dist)){ #if the total step distance is more than 10 times the distance between observed points, replace with equally spaced between the points
        x_step <- (point_2$x - point_1$x)/(point_2$rownum - point_1$rownum)
        y_step <- (point_2$y - point_1$y)/(point_2$rownum - point_1$rownum)
        for(j in (point_1$rownum+1):(point_2$rownum-1)){
          #paste("Row number:", j) %>%  print()
          loop_index <- j - point_1$rownum
          
          #paste("Initial x:", x$x[j]) %>%  print()
          x$x[j] <- x$x[point_1$rownum] + (x_step*loop_index)
          #paste("Final x:", x$x[j]) %>%  print()
          
          #paste("Initial y:", x$y[j]) %>%  print()
          x$y[j] <- x$y[point_1$rownum] + (y_step*loop_index)
          #paste("Final y:", x$y[j]) %>%  print()
        }
      } 
    }
    #Cleanup
    x$rownum <- NULL
    
    #transform back to 4326
    x_coords <- x %>%
      st_as_sf(coords = c("x", "y"), crs = 5070) %>% 
      st_transform(4326) %>% 
      st_coordinates() %>% 
      as.data.frame()
    
    x$x <- x_coords$X
    x$y <- x_coords$Y
    
    return(x)
  })

amwo_hmm <- nested_birds_2 %>% 
  unnest(cols = c(data))

plan(sequential)
```

Identify when there is > 30.2 km between observed points, and remove all predicted points between them
```{r include = FALSE}
plan(multisession)
nested_birds_2.5 <- amwo_hmm %>%
  group_by(ID) %>%
  nest()

nested_birds_2.5$data <- nested_birds_2 %>% 
  pull(data) %>% 
  future_map(.f = function(x){

    x <- x %>% 
      mutate(., rownum = 1:nrow(.))
    
    #Transform to 5070 so I can interpolate points
    # x_coords <- x %>%
    #   st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
    #   st_transform(5070) %>% 
    #   st_coordinates() %>% 
    #   as.data.frame()
    # 
    # x$x <- x_coords$X
    # x$y <- x_coords$Y
    
    observed_locs <- x %>%
      filter(locType == "o")
    
    rows_to_delete <- numeric()
    
    for(i in 1:(nrow(observed_locs)-1)){
      #print(i)
      point_1 <- observed_locs[i,] %>%
        st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>% 
        st_transform(5070)
      
      point_2 <- observed_locs[i + 1,] %>%
        st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>% 
        st_transform(5070)
      
      point_dist <- st_distance(point_1, point_2,) %>%
        as.numeric(.)
      
      # total_dist <- x[c(point_1$rownum, point_1$rownum:point_2$rownum),] %>%
      #   as.data.frame() %>% 
      #   prepData(type = "UTM") %>%
      #   pull(step) %>%
      #   sum(na.rm = TRUE)
      
      if(point_dist > 30200){ 
        rows_to_delete <- rows_to_delete %>% 
          append(values = (point_1$rownum + 1):(point_2$rownum - 1))
      } 
    }
    
    x <- x %>% 
      filter(!(rownum %in% rows_to_delete))
    
    #Cleanup
    x$rownum <- NULL
    
    #transform back to 4326
    # x_coords <- x %>%
    #   st_as_sf(coords = c("x", "y"), crs = 5070) %>% 
    #   st_transform(4326) %>% 
    #   st_coordinates() %>% 
    #   as.data.frame()
    # 
    # x$x <- x_coords$X
    # x$y <- x_coords$Y
    
    return(x)
  })

amwo_hmm <- nested_birds_2.5 %>% 
  unnest(cols = c(data))

plan(sequential)
```

Determine the mean distance to the nearest 7 points
```{r}
plan(multisession)

amwo_hmm$mean_dist_7 <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter)
    
    st_distance(x = iter_sf, y = other_locs) %>% 
      as.numeric() %>%
      sort() %>%
      .[2:8] %>% 
      mean(na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```

Determining the amount of time that the bird has spent/will spend within a 10km radius of the point
```{r}
plan(sequential)
amwo_hmm$residence_time <- amwo_hmm %>% 
  dplyr::select(ID, x, y) %>% 
  future_pmap(function(ID_iter, x_iter, y_iter){
    
    iter_sf <- data.frame(x = x_iter, y = y_iter) %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>% 
      st_transform(5070) %>% 
      st_buffer(10000) %>% #10 km radius
      transmute(intersection = 1)
    
    other_locs <- amwo_hmm %>%
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
      filter(ID == ID_iter) %>% 
      st_transform(5070) %>% 
      transmute(date = ymd(date))
    
    intersected_locs <- other_locs %>% 
      st_join(iter_sf) %>% 
      filter(intersection == 1)
    
    as.numeric(max(intersected_locs$date, na.rm = TRUE) - min(intersected_locs$date), na.rm = TRUE) %>% 
      return()
  }) %>% 
  unlist()

plan(sequential)
```

Determining the log distance from the first point to the current point
```{r}
plan(multisession)

nested_birds_3 <- amwo_hmm %>%
  group_by(ID) %>%
  nest()

nested_birds_3$data <- nested_birds_3 %>% 
  pull(data) %>% 
  future_map(.f = function(int){
    
    int <- int %>% 
      st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
    
    dist_vect <- st_distance(x = int[1,], y = int, by_element = FALSE) %>% #results in meters
      as.numeric() #NOTE: NEEDS sf 1.0-9 to work correctly
    
    # dist_vect <- log(dist_vect + 1.1)
    dist_vect <- if_else(dist_vect < 16100, 0, 1)
    
    int <- int %>% 
      st_drop_geometry() %>% 
      mutate(dist_start = dist_vect)
    
    return(int)
  })

amwo_hmm <- nested_birds_3 %>% 
  unnest(cols = c(data))

plan(sequential)
```

Extract breeding season abundance for each point
```{r}
ebirdst_breeding <- terra::rast(here("ebirdst_abundance", "amewoo_abundance_seasonal_breeding_max_2021.tif"))

amwo_hmm$breeding_abundance <- amwo_hmm %>% 
  st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
  st_transform(st_crs(ebirdst_breeding)) %>% 
  terra::vect() %>% 
  terra::extract(x = ebirdst_breeding, y = .) %>% 
  mutate(breeding = if_else(is.na(breeding), 0, breeding)) %>% 
  pull(breeding) 

amwo_hmm <- amwo_hmm %>% #simplify from abundance to breeding range
  mutate(breeding_abundance = if_else(breeding_abundance > 0, 1, 0)) 
```

```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(log_mean_dist_7 = log(mean_dist_7 + 0.1)) %>% #Adding a small # to deal with 0 distances
  as.data.frame() %>%
  prepData(type = "LL") %>% #, covNames = c("julian_day", "log_mean_dist_7")
  mutate(step = round(step, digits = 4)) %>%   #round down to a tenth of a meter, which is higher than our GPS precision
  mutate(step_500 = if_else(step < 30.2, 0, 1)) %>% #larger than 5km
  mutate(step_500 = if_else(!is.na(step_500), step_500, 0))
```

#remove early spring movements which throw off the hmm for NJ-2018-08-2019, NJ-2018-13-2019, and NJ-2018-15-2019. Add it back again at the end as a manually-delineated residential movement at the end (or not, as this code only cares about delineating state-shift dates)
```{r}
# early_spring_movement <- amwo_hmm %>%
#   mutate(id_time = paste(ID, as.character(time))) %>%
#   filter(id_time == "VA-2020-52-2020 2020-06-18 21:00:00" | id_time == "VA-2020-52-2020 2020-06-28 14:00:00") %>%
#   mutate(id_time = NULL)

early_spring_movement <- amwo_hmm %>%
  filter((ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32")) |
         (ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-14 00:00:00")) |
         (ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-05 00:00:00")))

amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "NJ-2018-08-2019" & time <= ymd_hms("2019-01-12 14:00:32"))) %>%
  filter(!(ID == "NJ-2018-15-2019" & time <= ymd_hms("2019-01-14 00:00:00"))) %>%
  filter(!(ID == "NJ-2018-13-2019" & time <= ymd_hms("2019-02-05 00:00:00")))

#additionally trimming RI-2020-31; I won't add it back in (not necessary for this workflow). Algorithm catches the tail end of fall migration and pushes it into spring mig too early.
amwo_hmm <- amwo_hmm %>%
  filter(!(ID == "RI-2020-31-2021" & time <= ymd_hms("2021-03-02 18:59:12")))

amwo_hmm <- amwo_hmm %>% #removing ranging movements
  filter(!(ID == "AL-2022-15-2022" & time == ymd_hms("2022-02-28 17:00:00"))) %>% 
  filter(!(ID == "AL-2021-12-2021" & time == ymd_hms("2021-02-25 17:00:00"))) %>%
  filter(!(ID == "NJ-2018-15-2019" & time == ymd_hms("2019-01-14 04:00:00"))) %>% 
  filter(!(ID == "VA-2019-45-2020" & time > ymd_hms("2020-06-22 04:00:00"))) %>% #same thing with midsummer movements
  filter(!(ID == "VA-2021-98-2022" & time > ymd_hms("2022-05-30 15:00:00"))) %>%
  filter(!(ID == "VA-2022-100-2022" & time > ymd_hms("2022-06-19 09:00:00"))) %>% 
  filter(!(ID == "VA-2019-36-2020" & time > ymd_hms("2020-06-19 01:59:28"))) %>% 
  filter(!(ID == "AL-2021-10-2021" & time == ymd_hms("2021-05-21 03:58:56"))) %>%
  filter(!(ID == "AL-2021-10-2021" & time == ymd_hms("2021-05-21 17:00:00"))) %>% 
  filter(!(ID == "AL-2021-12-2021" & time == ymd_hms("2021-02-26 05:02:56")))
```

remove birds with no individual step lengths >30.2km (20 miles). In practice this pulls birds that never initiate a substantial migratory movement but doesn't penalize birds that DO migrate, as they always make at least one substantial movement.
Also recording which individuals are removed
```{r}
amwo_hmm$min.step <- ifelse(amwo_hmm$step > 30.2, 1, 0)
individuals_removed_for_no_migratory_steps <- unique(amwo_hmm$ID [amwo_hmm$min.step == 1])
amwo_hmm <- amwo_hmm[(amwo_hmm$ID %in% amwo_hmm$ID [amwo_hmm$min.step == 1]) , ]
amwo_hmm$min.step <- NULL
```


Save data for use in the model
```{r}
save.image(file=here("classifier_spring", "spring_female_data.RData"))
```