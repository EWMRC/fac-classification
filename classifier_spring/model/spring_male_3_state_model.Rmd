---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

This is a streamlined version of what Erik originally wrote in momentuHMM_amwo_Spring_Male2. Uses HMMs to determine if birds settle after migration, and then uses a ruleset to define when each state starts and stops

Last bit: remove all of the false migrations

```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
```

Extract all locations from 2019, 2020, and 2021 from Jan 5th through June 30th
```{r include=FALSE}
login <- movebankLogin(username = "LA_Berigan", password="33szcNUtv4iyPGU")
amwo_2018 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20180105000000000", timestamp_end = "20180630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2019 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20190105000000000", timestamp_end = "20190630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2020 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20200105000000000", timestamp_end = "20200630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()

amwo_2021 <- getMovebankData(study = "American Woodcock Migration Ecology in Eastern North America", login = login, timestamp_start = "20210105000000000", timestamp_end = "20210630000000000", removeDuplicatedTimestamps=TRUE) %>% as.data.frame()
```

Formatting and cleaning, including creating time columns and simplifying to one location per day
```{r}
amwo_spring <- as.data.frame(rbind(amwo_2018, amwo_2019, amwo_2020, amwo_2021))

amwo_spring <- amwo_spring %>%
  transmute(ID = local_identifier,
            #time = as.POSIXct(round(force_tzs(timestamp, tzone = "GMT", tzone_out = "EST"), "hour")), #time rounded in EST
            time = timestamp,
            lon = location_long,
            lat = location_lat,
            tagtype = comments,
            sex = sex,
            age = taxon_detail,
            altitude = height_above_msl)

amwo_spring <- amwo_spring %>%
  mutate(t = strftime(time, format="%H:%M"),
         date = strftime(time, format="%Y-%m-%d")) #%>%
  #distinct(date, ID, .keep_all = TRUE) # remove multiple locations on same day, mainly retaining only 1 of 3 locations 1st day after marking
```

Converting all age classes to juvenile and adult
```{r}
amwo_spring <- amwo_spring %>%
  mutate(age = recode_factor(age,
                             "Second Year" = "juv",
                             "Hatch Year" = "juv",
                             "After Hatch Year" = "ad",
                             "After Second Year" = "ad",
                             "Third Year" = "ad",
                             "After Third Year" = "ad"))
```

Extracting tag type, schedule, state marked, and year
```{r}
amwo_spring <- amwo_spring %>%
  separate(tagtype, c("tagtype", "second", "schedule"), sep = " ") %>% 
  dplyr::select(-second) %>%
  mutate(ID2 = ID) %>%
  separate(ID2, c("m.state", "m.year", "third"), sep = "-") %>% 
  dplyr::select(-third)
```

Filtering to just males
```{r}
amwo_spring_males <- amwo_spring %>%
  filter(sex == "m")
```

Account for potential duplicate years by adding a year to the end of the id
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(year = strftime(time, format="%Y")) %>%
  mutate(animal_name = ID,
         ID = paste(ID, year, sep="-"))
```

Add a julian day column (new data stream)
```{r}
amwo_spring_males <- amwo_spring_males %>%
  mutate(julian_day = yday(ymd(date)))
```

Remove individuals with fewer than 3 locations, recording which ones were removed
```{r}
individuals_removed_for_too_few_locations <- amwo_spring_males %>%
  group_by(ID) %>%
  tally() %>%
  filter(n < 3) %>%
  pull(ID)

rm.ID <- amwo_spring_males %>%
  group_by(ID) %>%
  tally() %>%
  filter(n > 2) %>%
  pull(ID)

amwo_spring_males <- amwo_spring_males %>%
  filter(ID %in% rm.ID)
```

Flag individuals tagged after February 15th on the year of observation so that I can mark their initial stationary state as uncertain
```{r include = FALSE}
capture_dates <- readxl::read_excel(here::here("capture_sheet.xlsx"), col_types = c("text", "text", "date", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "text", "text", "text")) %>%
        mutate(`Argos ID` = as.character(`Argos ID`)) %>%
  transmute(animal_name = `Movebank ID`,
            capture_date = Date)

individuals_tagged_too_late <- amwo_spring_males %>%
  left_join(capture_dates) %>%
  filter((year == year(capture_date) & mdy(paste0("2/15/", year)) < capture_date)) %>% #remove locations when the bird was caught after Oct 15 in the year of concern
  dplyr::select(ID, animal_name, year) %>%
  distinct()
```

Flag individuals which died before May 15th on the year of observation so that I can mark their final stationary state as uncertain. 

### This will bias any survival analyses done with these designations ###
```{r}
individuals_died_too_early <- amwo_spring_males %>%
  group_by(ID) %>%
  summarise(max_time = max(time)) %>%
  mutate(max_date = mdy(paste0(month(max_time), "/", day(max_time), "/2020"))) %>%
  filter(max_date < mdy("5/15/2020")) %>%
  pull(ID)
```

# create momentuHMMData object; would specify covariates if included in the dataset
##  basically the step length and turn angles are now included
## Also create a data stream for difference in latitude (may be necessary for a ruleset: if not, remove)
```{r}
amwo_hmm <- amwo_spring_males %>%
  rename(x = lon, y = lat) 

amwo_hmm$lat_diff <- map(1:nrow(amwo_hmm),  function(i){
  if(i == 1){return(NA)} else{#for the first row, return 1
    if(amwo_hmm[i,"ID"] != amwo_hmm[i-1,"ID"]){ #is this the first point for this ID? Return NA
      return(NA)
    } else{
      return(amwo_hmm[i,"y"] - amwo_hmm[i-1,"y"])
    }
  }
}) %>% unlist()

amwo_hmm %>%
  mutate(lat_diff_abs = abs(lat_diff)) ->
  amwo_hmm

amwo_hmm %>%
  prepData(type = "LL", covNames = c("julian_day")) %>%
  mutate(step = round(step, digits = 2)) ->
  amwo_hmm
```

remove a transient summer movement which throws off the hmm for VA-2020-52-2020. Add it back again at the end as a manually-delineated residential movement at the end
```{r}
summer_transient_movement <- amwo_hmm %>%
  mutate(id_time = paste(ID, as.character(time))) %>% 
  filter(id_time == "VA-2020-52-2020 2020-06-19 01:59:28" | id_time == "VA-2020-52-2020 2020-06-28 19:01:20") %>%
  mutate(id_time = NULL)

amwo_hmm <- amwo_hmm %>%
  mutate(id_time = paste(ID, as.character(time))) %>% 
  filter(id_time != "VA-2020-52-2020 2020-06-19 01:59:28") %>%
  filter(id_time != "VA-2020-52-2020 2020-06-28 19:01:20") %>%
  mutate(id_time = NULL)
```

remove birds with no individual step lengths >30.2km (20 miles). In practice this pulls birds that never initiate a substantial migratory movement but doesn't penalize birds that DO migrate, as they always make at least one substantial movement.
Also recording which individuals are removed
```{r}
amwo_hmm$min.step <- ifelse(amwo_hmm$step>30.2, 1,0)
individuals_removed_for_no_migratory_steps <- unique(amwo_hmm$ID [amwo_hmm$min.step == 1])
amwo_hmm <- amwo_hmm[(amwo_hmm$ID %in% amwo_hmm$ID [amwo_hmm$min.step == 1]) , ]
amwo_hmm$min.step <- NULL
```

Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
knownStates <- amwo_hmm %>%
  group_by(ID) %>%
  mutate(ranks = row_number()) %>%
  mutate(known = ifelse(ranks == "1", 1, NA)) %>%
  pull(known)
```

##### trying 3-state model with fixed state transitions

Label states and create distributions for movements
```{r}
stateNames <- c("pre","migration", "post")
nsim <- 25 # number of simulations
dist <- list(step="gamma", angle="wrpcauchy") #, lat_diff_abs = "gamma" , pts_10mi_log = "norm"
```

fix step length parameters and state transitions
```{r}
fixPar <- list(beta=matrix(c(NA, -100, # pre-migration to transitions, can't go pre- to post
                     -100, NA,  #once entered migration can't go back to pre
                     -100, -100,
                     NA, -100,
                     -100, NA,
                     -100, -100), nrow = 2, byrow = TRUE)) #once entered post-migration, can't leave
```

These serve as the starting parameters for the HMM to optimize. Liam note: ask Erik where these came from
```{r}
Par0_m1 <- list(step=c(0.485, 211.927, 0.485, #mean in km
                       0.7327, 289.599, 0.7327, # SD in km
                       0.026, 0.036, 0.026), #zeromass ie how many zeroes expected in the distribution
                angle=c(0, 0, 0, #mean
                        0.5, 0.5, 0.5), #concentration
                julian_day = c(20, 50, 100, #mean
                        10, 10, 10))
                # lat_diff_abs = c(0.01, 1, 0.01,
                #                  0.01, 1, 0.01,
                #                  0.026, 0.036, 0.026)) 
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=3, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               #knownStates = knownStates,
               formula = ~julian_day, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames, nsim = nsim)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){return(1)} else{#for the first row, return 1
      if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
        return(1)
      } else{
        if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
          return(.x[i,"step_state"])
        } else{
          if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig
            return(1) 
          } else{ #in all other circumstances, return the current step state
            return(.x[i,"step_state"])
          }
        }
      }
    }
  }) %>% unlist()
  
  return(list(model = m1, results = .x))
}
```


I'll run this once initially, and this can be rerun after ruleset changes if necessary
```{r}
results_initial <- fit_and_predict(amwo_hmm) #results_initial includes both the created model and the df with predicted states 

#results_initial$model #probabilities of transition
#plot(results_initial$model, plotCI = TRUE) #inspect estimated parameters for each state and state classifications for each individual
#plotPR(results_initial$model) # lot observation index, theoretical quantiles, and lag

amwo_hmm <- results_initial$results
```

Ruleset: Pre-migration is all points up until the bird departs > 16.1km from its initial location for the final time
```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  first_loc <- amwo_hmm %>%
    filter(ID == ind) %>%
    head(n = 1) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)

  amwo_ind <- amwo_hmm %>%
    filter(ID == ind) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
    mutate(condition_distance_km_pre = as.numeric(st_distance(geometry, first_loc))/1000) %>%
    st_drop_geometry() %>%
    mutate(within_dist_pre = condition_distance_km_pre < 16.1) #10
  
  amwo_ind <- amwo_ind %>%
    mutate(row_num = 1:nrow(amwo_ind))
  
  highest_premig_row <- amwo_ind %>%
    filter(within_dist_pre == 1) %>%
    pull(row_num) %>%
    max()
  
  if(highest_premig_row < -1000){
    cat(crayon::magenta("no points within 16.1 kilometers of the centroid"))
  }
  
  amwo_ind <- amwo_ind %>% 
    mutate(point_state = if_else(row_num <= highest_premig_row, 1 , point_state)) %>% #point_state_premig_corrected
    mutate(condition_distance_km_pre = NULL,
           within_dist_pre = NULL,
           row_num = NULL)
}) %>%
  exec("bind_rows", .)

```

Ruleset: Post-migration is all points up until the bird comes within 8km of its final location for the first time, assuming that its final location is in state 3
```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  last_loc <- amwo_hmm %>%
    filter(ID == ind) %>%
    tail(n = 1) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE)
  
  amwo_ind <- amwo_hmm %>%
    filter(ID == ind) %>%
    st_as_sf(coords = c("x", "y"), crs = 4326, remove = FALSE) %>%
    mutate(condition_distance_km_post = as.numeric(st_distance(geometry, last_loc))/1000) %>%
    st_drop_geometry() %>%
    mutate(within_dist_post = condition_distance_km_post < 8) #16.1
  
  amwo_ind <- amwo_ind %>%
    mutate(row_num = 1:nrow(amwo_ind))
  
  lowest_postmig_row <- amwo_ind %>%
    filter(within_dist_post == 1) %>%
    pull(row_num) %>%
    min()
  
  if(lowest_postmig_row< -1000){
    cat(crayon::magenta("no points within 8 kilometers of the last point"))
  }
  
  if(last_loc$point_state == 3){
    amwo_ind <- amwo_ind %>% 
      mutate(point_state = if_else(row_num >= lowest_postmig_row, 3 , point_state)) %>% 
      mutate(within_dist_post = NULL, 
        condition_distance_km_post = NULL,
        row_num = NULL)
  } else {
    amwo_ind <- amwo_ind %>% 
      mutate(within_dist_post = NULL, 
        condition_distance_km_post = NULL,
        row_num = NULL)
  }

  return(amwo_ind)
}) %>%
  exec("bind_rows", .)
```

Add back in the movement from the summer transient bird (VA-2020-52-2020), manually classified as post-mig
```{r}
summer_transient_movement %>%
  mutate(step_state = c(3,NA), point_state = 3) ->
  summer_transient_movement

amwo_hmm %>%
  rbind(summer_transient_movement) ->
  amwo_hmm
```

Correct step state based on the new point states
If:
- This point state is migratory
or
- there is a change in point state between this and the next i
then the state is migratory. otherwise, it is equal to the current point state

if we're on the last row for the individual, skip this determination and return NA

```{r}
amwo_hmm <- map(unique(amwo_hmm$ID), function(ind){
  #print(ind)
  amwo_ind <- amwo_hmm %>%
    filter(ID == ind)
  
  ind_vect <- c()
  
  for(i in 1:(nrow(amwo_ind)-1)){
    #print(i)
    if(amwo_ind[i, "point_state"] == 2  | amwo_ind[i, "point_state"] != amwo_ind[i+1, "point_state"]){
      ind_vect <- append(ind_vect, 2)
    } else {
      ind_vect <- append(ind_vect, amwo_ind[i, "point_state"])
    }
  }
  
  ind_vect <- append(ind_vect, NA)
  
  amwo_ind$step_state <- ind_vect
  return(amwo_ind)
}) %>%
  exec("bind_rows", .)
```

Last bit: remove all of the false migrations
```{r}
amwo_hmm <- amwo_hmm %>%
  filter(ID != "RI-2019-21-2020",
         ID != "RI-2019-28-2020",
         ID != "RI-2019-29-2020",
         ID != "VA-2018-03-2018")
         #ID != "RI-2019-18-2020")
```

```{r}
amwo_hmm <- amwo_hmm %>%
  mutate(unk_init_flag = if_else(ID %in% individuals_tagged_too_late$ID, TRUE, FALSE)) %>%
  mutate(unk_term_flag = if_else(ID %in% individuals_died_too_early, TRUE, FALSE))
```

Save
```{r}
#Save amwo_hmm to a file that can be reviewed via the Shiny app
saveRDS(amwo_hmm, file = here::here("classifier_spring", "spring_male_3_state_model.rds"))
```



