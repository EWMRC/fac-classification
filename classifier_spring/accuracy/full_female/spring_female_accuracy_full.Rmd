---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---
```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Load data for use in the assessment
```{r}
load(file=here("classifier_spring", "spring_female_data.RData"))
```

Determine which individuals *didn't* die too early (here defined as 5/15)
```{r}
id_list <- unique(amwo_hmm$ID)
id_list <- id_list[!(id_list %in% individuals_died_too_early)]
```

Load the results object
```{r}
results <- readRDS(here("classifier_spring", "spring_female_4_state_model.rds"))
```

Frontmatter: prepare the model

Label states and create distributions for movements
```{r}
stateNames <- c("pre", "migration", "stopover", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern", log_mean_dist_7 = "norm", residence_time = "norm") #,  
```

fix step length parameters and state transitions
```{r}
fixPar <- list(beta=matrix(c(NA, -1000,	-1000,	-1000,	NA,	NA,	-1000,	NA,	-1000,	-1000,	-1000,	-1000), nrow = 1, byrow = TRUE),
               step_500 = c(0.000000001, 0.999999999, 0.000000001, 0.000000001))
```

These serve as the starting parameters for the HMM to optimize.
```{r}
Par0_m1 <- list(step=c(0.260832696, 9.429288e+01, 0.323209095, 0.1581120, #mean in km
                       0.434046082, 9.829083e+01, 0.565636024 , 0.2682378, # SD in km
                       0.002864053, 1.549953e-09, 0.008935152, 0.0101826), #zeromass ie how many zeroes expected in the distribution
                angle=c(0.001212793, -0.004443658, -0.004534878, 0.0003999368, #mean
                        0.882238488, 0.911903062, 0.405040026, 0.7535390314),
                y = c(35.142723, 40.642156, 41.012048,  44.801910,
                      2.567658, 4.407258, 3.666311, 3.010217),
                julian_day = c(41.63823, 86.00518, 88.73997, 141.08671, #mean
                               20.60346, 26.04991, 25.50664, 23.33606),#concentration
                log_mean_dist_7 = c(3.601858, 9.920471, 4.539150, 3.114167, #mean
                                    1.610840, 2.643817, 2.938573, 1.637662), #sd
                residence_time = c(49.87944, 7.546966, 26.48728, 66.52459, #mean
                                   21.66159, 16.575491, 20.09901, 22.88829), #sd
                dist_start = c(0.01667985, 0.9264421, 0.9762556, 0.999999), #prob
                step_500 = c(0.002299856, 0.99999, 7.443581e-09, 0.00255622), #prob
                breeding_abundance = c(0.1159913, 0.4453295, 0.5308599, 0.8146863)) #prob
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x, ks){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=4, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               #userBounds = userBounds,
               #workBounds = workBounds,
               #DM = DM,
               knownStates = ks,
               #formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1 | i == 1){
      return(1) #for the first and second rows, return 1
    } else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
      return(1)
    } else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
      return(.x[i,"step_state"])
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1 & .x[i,"ID"] == .x[i-2,"ID"]){ #is the current step state mig and the previous step pre-mig, and is this not step 1 or 2? Return pre-mig
      return(1)
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
      return(3)
    } else{ #in all other circumstances, return the current step state
      return(.x[i,"step_state"])
    }
    
  }) %>% unlist()
  
  #Fix the RI problem birds
  # .x <- .x %>% 
  #   group_by(ID) %>%
  #   mutate(ranks = row_number()) %>%
  #   mutate(point_state = ifelse(ranks == "1" & ID %in% RI_problems, 1, point_state)) %>% 
  #   ungroup() %>% 
  #   dplyr::select(-ranks)
  
  return(list(model = m1, results = .x))
}
```

# and now for the accuracy assessment
```{r}
iterate_ids <- function(id_iter, jul_day_cutoff, rn){
  amwo_hmm_clipped <- amwo_hmm %>% #remove locations for the ID in question after the cutoff date
    filter(!(ID == id_iter & julian_day > jul_day_cutoff))
  
  ## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
  known_state_key <- amwo_hmm_clipped %>%
    group_by(ID) %>%
    mutate(ranks = row_number()) %>% # rank observations (requires correct sorting), ifelse to convert first observations to state 1 and all others NA
    ungroup() %>% 
    mutate(known = ifelse(estimate_starting_state == FALSE & ranks == 1, yes = 1, no = NA)) %>%
    mutate(r1p1s2 = if_else(known == 1 & step > 30.2, true = TRUE, false = FALSE)) %>% #if known == 1 and step >30.2, mark as a "rank 1 point 1 step 2" event to be reclassified in post-processing
    mutate(r1p1s2 = replace_na(r1p1s2, replace = FALSE)) %>% #deals with NA issues
    mutate(known = ifelse(step > 30.2, 2, known)) %>% #if step length is >30.2, then it must be mig (even if known is already 1) 
    mutate(known = ifelse(ID == "VA-2021-91-2021" & ranks %in% c(16, 17, 18), 2, known)) %>% #crw stops the bird from slipping into mig
    mutate(known = ifelse(ID == "VA-2021-92-2021" & ranks %in% c(6, 7, 8), 2, known)) %>% #crw stops the bird from slipping into mig
    mutate(known = ifelse(ID == "NJ-2018-15-2019" & julian_day == 46, 2, known)) %>% 
    mutate(known = ifelse(ID == "VA-2019-22-2019" & julian_day == 99, 2, known)) %>% 
    mutate(known = ifelse(ID == "ME-2018-13-2019" & julian_day == 161, 2, known)) %>% 
    mutate(known = ifelse(ID == "NY-2022-40-2022" & ranks == 1, 3, known)) %>%  #bird that migrated after nesting starts in stopover state
    mutate(known = ifelse(ID == "RI-2018-11-2019" & ranks == 95, 4, known)) #bird is recaptured and re-transmittered at the last mig location the following Oct, so we know that it is settled here
  
  # mutate(known = ifelse(known == 1 & ID %in% RI_problems, 2, known)) %>%
  
  amwo_hmm_clipped$known <- known_state_key$known
  amwo_hmm_clipped$r1p1s2 <- known_state_key$r1p1s2
  
  knownStates <- amwo_hmm_clipped$known
  
  # fit the model
  results_modified <- fit_and_predict(amwo_hmm_clipped, ks = knownStates)
  
  #retrieve the modified ending state
  end_state_modified <- results_modified$results %>% 
    filter(ID == id_iter & julian_day == jul_day_cutoff) %>% 
    pull(point_state)
  
  #retrieve the real ending state
  end_state_true <- results %>% 
    filter(ID == id_iter & julian_day == jul_day_cutoff) %>% 
    pull(point_state)
  
  #report the cutoff date, ID, modified ending state, and real ending state in a tibble, which will be the output of the loop
  tibble(cutoff_date = jul_day_cutoff,
         ID = id_iter,
         end_modified = end_state_modified,
         end_true = end_state_true) %>% 
    return()
}
```


```{r}
cutoffs <- c("3/15/2020", "4/1/2020", "4/15/2020", "5/1/2020", "5/15/2020", "6/1/2020", "6/15/2020") %>% 
  mdy() %>% 
  yday()

#now iterating through individuals
set.seed(8)
id_subsample <- id_list %>% sample(size = 50)

parameters_to_run <- expand.grid(id_subsample, cutoffs) %>%
  mutate(rn = row_number())
colnames(parameters_to_run) <- c("id_iter", "jul_day_cutoff", "rn")

parameters_to_run <- parameters_to_run %>% #if I omit the bird from the model, omit it from the accuracy evaluation
  filter(!(id_iter %in% c("NJ-2019-28-2020", "NS-2019-02-2020", "RI-2020-42-2021", "RI-2021-47-2022", "RI-2021-52-2022")))

# prior_results <- read.csv("accuracy_results_female.csv") %>% #ensure that I'm not duplicating past labor
#   transmute(combined = paste0(cutoff_date, "_",ID))
# 
# parameters_to_run <- parameters_to_run %>% 
#   mutate(combined = paste0(jul_day_cutoff, "_",id_iter)) %>% 
#   filter(!(combined %in% prior_results$combined)) %>% 
#   mutate(combined = NULL)
```

```{r}
plan(multisession)
tbl_list <- future_pmap(.l = parameters_to_run, 
                        .f = iterate_ids, 
                        .options = furrr_options(seed = 8))
plan(sequential)
```

```{r}
accuracy_results_female <- tbl_list %>% 
  do.call(rbind, .)

# Append results to previous runs
write.table(accuracy_results_female, "accuracy_results_female_null.csv",
            append = TRUE,
            sep = ",",
            col.names = FALSE,
            row.names = FALSE,
            quote = FALSE)
```

# Read the results back in and plot
```{r}
accuracy_results_female <- read_csv("accuracy_results_female_null.csv")
```

Coding the results in a ggplot-friendly format
```{r}
accuracy_results_female <- accuracy_results_female %>% 
  mutate(false_mig = if_else((end_modified == 2 | end_modified == 3) & end_true == 4, 1, 0)) %>% 
  mutate(false_postmig = if_else((end_true == 2 | end_true == 3) & end_modified == 4, 1, 0)) %>% 
  pivot_longer(cols = c("false_mig", "false_postmig"), names_to = "test", values_to = "result") %>% 
  group_by(cutoff_date, test) %>% 
  summarise(percent_error = mean(result), std_err = plotrix::std.error(result)) %>% 
  ungroup()
```

```{r}
ggplot(data = accuracy_results_female, mapping = aes(x = cutoff_date, y = percent_error, col = test)) +
  geom_point(position=position_dodge(width=4)) +
  geom_errorbar(aes(ymin = percent_error - std_err*1.96, ymax = percent_error + std_err*1.96), width = 2,
                position=position_dodge(width=4),) +
  theme_bw() +
  scale_y_continuous(labels = scales::percent) +
  labs(y = "Percent error", x = "Julian day", col = "Classification error")

ggsave("spring_female_classification_error_2_27_23.png", width = 7, height = 5)
```

