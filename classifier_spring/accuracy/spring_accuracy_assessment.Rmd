---
title: "R Notebook"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---
```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(move)
library(momentuHMM)
library(leaflet)
library(RColorBrewer)
library(sf)
library(furrr)
library(here)
library(crawl)
```

Load data for use in the assessment
```{r}
load(file=here("classifier_spring", "spring_male_data.RData"))
```

Determine which individuals *didn't* die too early (here defined as XX/XX)
```{r}
id_list <- unique(amwo_hmm$ID)
id_list <- id_list[!(id_list %in% individuals_died_too_early)]
```

Load the results object
```{r}
results <- readRDS(here("classifier_spring", "spring_male_5_state_model.rds"))
```

Frontmatter: prepare the model

Assign a starting state for each individual
```{r}
## rank observations (requires correct sorting), ifelse to covert first observations to state 1 and all others NA
```

Label states and create distributions for movements
```{r}
stateNames <- c("pre", "migration", "stopover", "settling", "post")
dist <- list(step="gamma", angle="wrpcauchy", y = "norm", julian_day = "norm", log_mean_dist_7 = "norm", residence_time = "norm", dist_start = "bern", step_500 = "bern", breeding_abundance = "bern") #, lat_diff_abs = "gamma" , pts_10mi_log = "norm"
```

fix step length parameters and state transitions
```{r}
fixPar <- list(beta=matrix(c(NA,	-10000,	-10000,	-10000,	
                             -10000,	NA,	NA,	NA,	
                             -10000,	NA,	-10000, -10000, 
                             -10000, -10000, -10000, NA, 
                             -10000,	-10000,	-10000,	NA), nrow = 1, byrow = TRUE),
               step_500 = c(NA, 0.999999999, NA, NA, NA)) 
```

These serve as the starting parameters for the HMM to optimize.
```{r}
Par0_m1 <- list(step=c(0.293641627, 79.029506936, 0.157361645, 0.250739740, 0.086056474, #mean in km
                       0.455493251, 95.302307236, 0.211421668, 0.384581337, 0.128558113, # SD in km
                       0.005159307, 0.006024863, 0.006664064, 0.005636388, 0.006973284), #zeromass ie how many zeroes expected in the distribution
                angle=c(0.001353412, 0.0006979447, 0.01168102, 0.0005445842, 0, #mean
                        0.917280917, 0.9754146876, 0.59501513, 0.7614896594, 0.99999), #concentration
                y = c(34.83030, 40.173268, 40.426752,  44.689995, 43.678101,
                      3.11158, 4.497807, 3.668652, 2.267504, 4.109156),
                julian_day = c(40.14297, 79.36682, 80.54528, 135.69949, 136.7710, #mean
                        19.89502, 27.50774, 23.92289, 25.77254, 30.0146),
                log_mean_dist_7 = c(4.126427, 9.965601, 4.959182, 3.797415, 3.581605, #mean
                                1.679125, 2.403601, 2.736004, 1.536724, 1.806670), #sd
                residence_time = c(39.91826, 6.848351, 53.64592, 71.41284, 70.66562, #mean
                                   20.41741, 13.174650, 35.49282, 21.65228, 25.53273), #sd
                dist_start = c(0.00530222, 0.9276614, 0.9750638, 0.9955032, 0.9882519), #prob
                step_500 = c(0.1336989, 0.99999, 0.06175472, 0.1351401, 0.04079765), #prob
                breeding_abundance = c(0.1183127, 0.3973247, 0.442492, 0.7108834, 0.5959887)) #prob
```

Create a function that fits the model, predicts states for each step (predicted and observed) and input in the dataset. Note: the listed x y is the starting location of the step. Then use this to determine what the bird's state was at any given point
```{r}
fit_and_predict <- function(.x, ks){
  set.seed(8)
  m1 <- fitHMM(data=.x, nbStates=5, dist=dist, Par0 = Par0_m1,
               estAngleMean = list(angle=TRUE),
               fixPar=fixPar,
               #userBounds = userBounds,
               #workBounds = workBounds,
               #DM = DM,
               knownStates = ks,
               #formula = ~step_cov, #state 2 to 3. page 47 of vignette shows how to create the beta matrix
               stateNames = stateNames)
  
  .x$step_state <- viterbi(m1)
  
  #step state shows the bird's behavior between points, point state shows the birds behavior at points
  .x$point_state <- map(1:nrow(.x),  function(i){
    if(i == 1){
      return(1) #for the first row, return 1
    } else if(.x[i,"ID"] != .x[i-1,"ID"]){ #is this the first point for this ID? Return the starting state
      return(1)
    } else if(.x[i,"step_state"] == .x[i-1,"step_state"]){ #is the current step state the same as the last step state? Return the current step state
      return(.x[i,"step_state"])
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 1){ #is the current step state mig and the previous step pre-mig? Return pre-mig
      return(1)
    } else if(.x[i,"step_state"] == 2 & .x[i-1,"step_state"] == 3){#is the current step state mig and the previous step stopover? Return stopover
      return(3)
    } else{ #in all other circumstances, return the current step state
      return(.x[i,"step_state"])
    }

  }) %>% unlist()
  
  return(list(model = m1, results = .x))
}
```


# nd now for the accuracy assessment

First: iterate through dates. Gonna start with a single date for now (6/15) and add an iterative framework on top of this. Note that this will likely be the level at which I implement parallel processing.

Will likely need to subsample the ids down to a reasonable # for processing.
```{r}
iterate_ids_male <- function(id_iter, jul_day_cutoff, rn){
  amwo_hmm_clipped <- amwo_hmm %>% #remove locations for the ID in question after the cutoff date
    filter(!(ID == id_iter & julian_day > jul_day_cutoff))
  
  knownStates <- amwo_hmm_clipped %>%
    group_by(ID) %>%
    mutate(ranks = row_number()) %>%
    mutate(known = ifelse(ranks == "1", 1, NA)) %>%
    pull(known)
  
  results_modified <- fit_and_predict(amwo_hmm_clipped, ks = knownStates)
  
  #retrieve the modified ending state
  end_state_modified <- results_modified$results %>% 
    filter(ID == id_iter & julian_day == jul_day_cutoff) %>% 
    pull(point_state)
  
  #retrieve the real ending state
  end_state_true <- results %>% 
    filter(ID == id_iter & julian_day == jul_day_cutoff) %>% 
    pull(point_state)
  
  #report the cutoff date, ID, modified ending state, and real ending state in a tibble, which will be the output of the loop
  tibble(cutoff_date = jul_day_cutoff,
         ID = id_iter,
         end_modified = end_state_modified,
         end_true = end_state_true) %>% 
    return()
}
```


```{r}
cutoffs <- c("3/15/2020","4/15/2020", "5/15/2020", "6/15/2020") %>% 
  mdy() %>% 
  yday()

#now iterating through individuals
set.seed(8)
id_subsample <- id_list %>% sample(size = 20)

parameters_to_run <- expand.grid(id_subsample, cutoffs) %>%
  mutate(rn = row_number())
colnames(parameters_to_run) <- c("id_iter", "jul_day_cutoff", "rn")

plan(multisession)
tbl_list <- future_pmap(.l = parameters_to_run, 
                        .f = iterate_ids_male, 
                        .options = furrr_options(seed = 8))
plan(sequential)
```


```{r}
accuracy_results_male <- tbl_list %>% 
  do.call(rbind, .)

# Append results to previous runs
write.table(accuracy_results_male, "accuracy_results_male.csv",
          append = TRUE,
          sep = ",",
          col.names = FALSE,
          row.names = FALSE,
          quote = FALSE)
```


Alternative, computationally-lighter method: create a new m1$covsDelta using the knownStates prior to using viterbi. Hence, rerun viterbi but not the model.
This didn't work. Could potentially get something working if I figured out why this is glitching. If not, then I could always do this the hard way.
```{r}
# covsDelta_rows <- knownStates %>% as.logical() %>% which()
# q <- matrix(data = 1, nrow = length(covsDelta_rows), ncol = 1)
# row.names(q) <- covsDelta_rows
# colnames(q) <- "(Intercept)"
# attr(q, "assign") <- 0
# 
# # mod <- readRDS(here("classifier_spring", "spring_male_5_state_parameters.rds"))
# mod <- 
# t <- viterbi(mod)
# 
# m1 <- results_modified$model
# m1$knownStates <- knownStates
# m1$data <- amwo_hmm_clipped
# m1$covsDelta <- q
# z <- viterbi(m1)

```

